<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>LifeXP</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Tailwind CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React (production) UMD -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for inline JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="bg-slate-50">
    <div id="root"></div>

    <script type="text/babel">
/* =========================
   LifeXP — Single-file App
   ========================= */
const { useEffect, useMemo, useState } = React;

const APP_VERSION = "v0.5.0";

/* ===== Utils ===== */
const todayISO = () => new Date().toISOString().slice(0, 10);
const yestISO = () => { const d = new Date(); d.setDate(d.getDate() - 1); return d.toISOString().slice(0, 10); };
const uid = () => (crypto?.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));

/* XP curve: TotalXP(level) = 50 * L * (L + 1)  → ΔXP to next = 100*(L+1) */
const totalXpForLevel = (L) => 50 * L * (L + 1);
const levelFromTotalXp = (xp) => Math.max(0, Math.floor((-1 + Math.sqrt(1 + (4 * xp) / 50)) / 2));

/* Skill Points per level (gentle) */
const skillPointsForLevel = (L) => 1 + Math.floor(Math.sqrt(L) / 2);

/* Milestones */
const MILESTONES = [
  { level: 10, sp: 2, badge: "Apprentice" },
  { level: 25, sp: 3, badge: "Adept" },
  { level: 50, sp: 5, badge: "Expert" },
  { level: 75, sp: 6, badge: "Master" },
  { level: 100, sp: 8, badge: "Grandmaster" },
];

/* Skill Tree (Progress-Knight vibe) */
const SKILL_TREE = {
  focus:      { key: "focus",      name: "Focus",      desc: "Tasks XP +2%/lvl (max +50%). Also +1% passive rate/lvl (max +20%).", type: "percent", perLevel: 0.02, max: 25, cost: (lvl) => 1 + Math.floor(lvl / 2) },
  momentum:   { key: "momentum",   name: "Momentum",   desc: "Raise streak bonus cap +0.05/lvl (max +0.5).",                      type: "cap",     perLevel: 0.05, max: 10, cost: (lvl) => 2 + Math.floor(lvl / 2) },
  scholar:    { key: "scholar",    name: "Scholar",    desc: "Project reward XP +3%/lvl (max +60%).",                               type: "percent", perLevel: 0.03, max: 20, cost: (lvl) => 1 + Math.floor(lvl / 2) },
  efficiency: { key: "efficiency", name: "Efficiency", desc: "+1 base XP to tasks per lvl (max +10).",                             type: "flat",    perLevel: 1,    max: 10, cost: (lvl) => 1 + lvl },
};

/* Passive Focus rates (XP/min) + bonus per full 25-min block */
const PASSIVE_RATES = { Training: 0.8, Language: 1.0, Study: 1.2 };
const PASSIVE_BLOCK_BONUS = 5;

/* ==== Passive XP caps (now configurable) ==== */
const DEFAULT_CAPS = { total: 240, perCat: 120 }; // raised from 120/60

function capsForLevel(level) {
  const baseTotal = 180, basePerCat = 90;
  return {
    total: Math.min(400, baseTotal + 3 * level),   // +3 XP/level, cap 400
    perCat: Math.min(160, basePerCat + 1 * level), // +1 XP/level, cap 160
  };
}

function dynamicCaps(level, todayActiveTotal) {
  const baseT = 160, baseC = 80;
  return {
    total: Math.min(400, baseT + Math.floor(0.5 * todayActiveTotal) + 2 * level),
    perCat: Math.min(160, baseC + Math.floor(0.25 * todayActiveTotal) + 1 * level),
  };
}

function computeCaps(level, todayActiveTotal, settings) {
  const mode = settings?.capMode || "static";
  if (mode === "level")   return capsForLevel(level);
  if (mode === "dynamic") return dynamicCaps(level, todayActiveTotal);
  return {
    total: settings?.staticTotal ?? DEFAULT_CAPS.total,
    perCat: settings?.staticPerCat ?? DEFAULT_CAPS.perCat,
  };
}

/* Level Titles (themes) + Epithets */
const TITLE_THEMES = {
  fantasy:   ["Novice","Apprentice","Adept","Journeyman","Expert","Master","Archmaster","Sage","Mythic","Ascendant","Paragon"],
  scifi:     ["Cadet","Specialist","Technician","Analyst","Operative","Engineer","Navigator","Commander","Captain","Admiral","Fleet Architect"],
  scholar:   ["Learner","Reader","Researcher","Scholar","Lecturer","Professor","Senior Professor","Dean","Provost","Chancellor","Laureate"],
  developer: ["Learner","Debugger","Coder","Developer","Engineer","Senior Engineer","Tech Lead","Architect","Principal","Distinguished","Fellow"],
  athletics: ["Rookie","Trainee","Contender","Challenger","Competitor","Champion","Elite","National","International","World-Class","Legendary"],
  minimal:   ["Seed","Sprout","Stem","Branch","Canopy","Grove","Valley","Ridge","Summit","Skyline","Zenith"],
};

function titleFromLevel(level, theme="fantasy"){
  const pack = TITLE_THEMES[theme] || TITLE_THEMES.fantasy;
  const idx = Math.min(Math.floor(level/10), pack.length-1);
  return pack[idx];
}
function epithetFromStats({focusL, scholarL, efficiencyL, momentumL, weekPassiveRatio, weekTasksPerDay}){
  if (focusL >= 10) return "the Focused";
  if (scholarL >= 10) return "the Scholar";
  if (efficiencyL >= 8) return "the Efficient";
  if (momentumL >= 8) return "the Unstoppable";
  if (weekPassiveRatio <= 0.30 && weekTasksPerDay >= 3) return "the Doer";
  return null;
}

/* LocalStorage Hook */
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    try { const raw = localStorage.getItem(key); return raw ? JSON.parse(raw) : initialValue; } catch { return initialValue; }
  });
  useEffect(() => { localStorage.setItem(key, JSON.stringify(value)); }, [key, value]);
  return [value, setValue];
}

/* ===================== App ===================== */
function LifeXPApp() {
  /* State */
  const [tasks, setTasks] = useLocalStorage("lifexp.tasks", []);
  const [projects, setProjects] = useLocalStorage("lifexp.projects", []);
  const [xp, setXp] = useLocalStorage("lifexp.xp", 0);
  const [skill, setSkill] = useLocalStorage("lifexp.skill", { points: 0, upgrades: {} });
  const [lastLevel, setLastLevel] = useLocalStorage("lifexp.lastLevel", 0);
  const [milestones, setMilestones] = useLocalStorage("lifexp.milestones", { claimed: [] });
  const [alerts, setAlerts] = useState([]);
  const [dateInfo, setDateInfo] = useLocalStorage("lifexp.dateInfo", { lastOpen: todayISO() });
  const [log, setLog] = useLocalStorage("lifexp.log", []); // entries: {id,date,type,amount,meta}
  const [session, setSession] = useLocalStorage("lifexp.session", null); // focus session
  const [titleTheme, setTitleTheme] = useLocalStorage("lifexp.titleTheme", "fantasy");
  const [settings, setSettings] = useLocalStorage("lifexp.settings", {
    capMode: "static",                 // 'static' | 'level' | 'dynamic'
    staticTotal: DEFAULT_CAPS.total,   // used when static
    staticPerCat: DEFAULT_CAPS.perCat,
  });

  /* Migrations */
  useEffect(() => { if (!skill.upgrades) setSkill({ points: skill.points || 0, upgrades: {} }); }, []);

  /* Alerts */
  function pushAlert(message) {
    const id = uid();
    setAlerts((a) => [...a, { id, message }]);
    setTimeout(() => setAlerts((a) => a.filter((x) => x.id !== id)), 4000);
  }

  /* Daily rollover (reset per-day fields) */
  useEffect(() => {
    const today = todayISO();
    if (dateInfo.lastOpen !== today) {
      setTasks((prev) => prev.map((t) => {
        const wasYesterday = t.lastCompleted === yestISO();
        const brokeStreak = t.lastCompleted && !wasYesterday;
        return { ...t, timesCompletedToday: 0, streak: brokeStreak ? 0 : t.streak || 0 };
      }));
      setDateInfo({ lastOpen: today });
    }
  }, []);

  /* Level math */
  const level = useMemo(() => levelFromTotalXp(xp), [xp]);
  const currentLevelFloor = totalXpForLevel(level);
  const nextLevelFloor = totalXpForLevel(level + 1);
  const progress = Math.min(1, (xp - currentLevelFloor) / (nextLevelFloor - currentLevelFloor));

  /* Skill modifiers */
  const U = skill.upgrades || {};
  const focusL = U.focus || 0;
  const momentumL = U.momentum || 0;
  const scholarL = U.scholar || 0;
  const efficiencyL = U.efficiency || 0;
  const tasksMult = 1 + Math.min(focusL * 0.02, 0.5);
  const passiveMult = 1 + Math.min(focusL * 0.01, 0.2);
  const projectMult = 1 + Math.min(scholarL * 0.03, 0.6);
  const baseFlat = Math.min(efficiencyL * 1, 10);
  const streakCap = 2 + Math.min(momentumL * 0.05, 0.5);

  /* Level-up: SP + milestones */
  useEffect(() => {
    if (level > lastLevel) {
      let baseSP = 0; for (let L = lastLevel + 1; L <= level; L++) baseSP += skillPointsForLevel(L);
      if (baseSP > 0) setSkill((s) => ({ ...s, points: (s.points || 0) + baseSP }));
      const newly = MILESTONES.filter((m) => m.level > lastLevel && m.level <= level && !(milestones.claimed || []).includes(m.level));
      if (newly.length) {
        const bonus = newly.reduce((sum, m) => sum + (m.sp || 0), 0);
        if (bonus) setSkill((s) => ({ ...s, points: (s.points || 0) + bonus }));
