<!doctype html>
<html class="dark">
  <head>
    <meta charset="utf-8" />
    <title>LifeXP</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      // Tailwind dark mode
      tailwind.config = { darkMode: 'class' };
    </script>
    <!-- React 18 UMD + Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Firebase (v12.2.1) -->
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
      import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-analytics.js";
      import {
        getAuth,
        onAuthStateChanged,
        signInWithEmailAndPassword,
        createUserWithEmailAndPassword,
        signOut
      } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js";
      import {
        getFirestore,
        doc, getDoc, setDoc, updateDoc, serverTimestamp
      } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js";

      // Firebase Configuration (provided)
      const firebaseConfig = {
        apiKey: "AIzaSyCWXb-BjKjgkJOvbd6OPd2bRQASPc-Qfm8",
        authDomain: "lifexp-94659.firebaseapp.com",
        projectId: "lifexp-94659",
        storageBucket: "lifexp-94659.firebasestorage.app",
        messagingSenderId: "164525761316",
        appId: "1:164525761316:web:1cbe7c79aa1585953cc9b1",
        measurementId: "G-KCWXJVSRGQ"
      };

      const app = initializeApp(firebaseConfig);
      window.firebaseApp = app;
      const analytics = getAnalytics(app);
      window.firebaseAnalytics = analytics;

      // Expose to app code
      window.firebaseAuth = getAuth(app);
      window.firebaseDb = getFirestore(app);
      window.firebaseAuthMethods = {
        onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut
      };
      window.firebaseDbMethods = { doc, getDoc, setDoc, updateDoc, serverTimestamp };
    </script>
  </head>
  <body class="bg-neutral-950 text-neutral-100">
    <div id="root"></div>

    <script type="text/babel">
      const { useEffect, useMemo, useState } = React;

      // ================== Utils ==================
      const todayISO = () => new Date().toISOString().slice(0,10); // YYYY-MM-DD
      const yestISO = () => { const d=new Date(); d.setDate(d.getDate()-1); return d.toISOString().slice(0,10); };
      const nowTs = () => Date.now();
      const uid = () => (crypto?.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));

      // Week helpers (ISO week key like 2025-W37)
      function isoWeekKey(dateStr) {
        const d = dateStr ? new Date(dateStr) : new Date();
        const dt = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
        const dayNum = dt.getUTCDay() || 7;
        dt.setUTCDate(dt.getUTCDate() + 4 - dayNum);
        const yearStart = new Date(Date.UTC(dt.getUTCFullYear(),0,1));
        const weekNum = Math.ceil((((dt - yearStart) / 86400000) + 1) / 7);
        return `${dt.getUTCFullYear()}-W${String(weekNum).padStart(2,'0')}`;
      }
      const startOfToday = () => { const d=new Date(); d.setHours(0,0,0,0); return d.getTime(); };

      // Median helper
      function median(arr) {
        if (!arr.length) return null;
        const a = [...arr].sort((x,y)=>x-y);
        const m = Math.floor(a.length/2);
        return a.length%2 ? a[m] : (a[m-1]+a[m])/2;
      }

      // ================== Progression math ==================
      // Quadratic cumulative XP: TotalXP(level) = 50 * L * (L+1)
      const totalXpForLevel = (L) => 50*L*(L+1);
      const levelFromTotalXp = (xp) => Math.max(0, Math.floor( (-1 + Math.sqrt(1 + (4*xp)/50)) / 2 ));
      const skillPointsForLevel = (L) => 1 + Math.floor(Math.sqrt(L)/2);

      const MILESTONES = [
        { level: 10, sp: 2, badge: "Apprentice" },
        { level: 25, sp: 3, badge: "Adept" },
        { level: 50, sp: 5, badge: "Expert" },
        { level: 75, sp: 6, badge: "Master" },
        { level: 100, sp: 8, badge: "Grandmaster" },
      ];

      // Achievement system - beyond level milestones
      const ACHIEVEMENTS = [
        { id: "first_task", name: "Getting Started", desc: "Complete your first task", condition: (data) => data.tasksCompleted >= 1, icon: "🎯" },
        { id: "streak_7", name: "Consistent", desc: "7-day task streak", condition: (data) => data.maxStreak >= 7, icon: "🔥" },
        { id: "streak_30", name: "Unstoppable", desc: "30-day task streak", condition: (data) => data.maxStreak >= 30, icon: "⚡" },
        { id: "focus_master", name: "Focus Master", desc: "100 hours of focus sessions", condition: (data) => data.totalFocusHours >= 100, icon: "🧘" },
        { id: "project_finisher", name: "Project Finisher", desc: "Complete 10 projects", condition: (data) => data.projectsCompleted >= 10, icon: "🏆" },
        { id: "early_bird", name: "Early Bird", desc: "Complete 50 tasks before 9 AM", condition: (data) => data.earlyTasks >= 50, icon: "🌅" },
        { id: "night_owl", name: "Night Owl", desc: "Complete 50 tasks after 10 PM", condition: (data) => data.nightTasks >= 50, icon: "🦉" },
        { id: "efficiency_expert", name: "Efficiency Expert", desc: "Complete 100 tasks under estimated time", condition: (data) => data.efficientTasks >= 100, icon: "⚡" },
        { id: "dedication", name: "Dedication", desc: "Log activity for 100 consecutive days", condition: (data) => data.consecutiveDays >= 100, icon: "💪" },
        { id: "xp_master", name: "XP Master", desc: "Earn 10,000 XP in a single day", condition: (data) => data.maxDailyXP >= 10000, icon: "💎" },
      ];

      const SKILL_TREE = {
        focus: { key: "focus", name: "Focus", desc: "Tasks XP +2%/lvl (max +50%). Passive rate +1%/lvl (max +20%).", max: 25, cost: lvl => 1 + Math.floor(lvl/2) },
        momentum: { key: "momentum", name: "Momentum", desc: "Raise streak bonus cap +0.05/lvl (max +0.5).", max: 10, cost: lvl => 2 + Math.floor(lvl/2) },
        scholar: { key: "scholar", name: "Scholar", desc: "Project reward XP +3%/lvl (max +60%).", max: 20, cost: lvl => 1 + Math.floor(lvl/2) },
        efficiency: { key: "efficiency", name: "Efficiency", desc: "+1 base XP to tasks per lvl (max +10).", max: 10, cost: lvl => 1 + lvl },
      };

      // ================== ML-Enhanced Dual-Track System ==================
      
      // Dual-Track System Configuration
      const DUAL_TRACK_CONFIG = {
        // XP Distribution Weights
        distribution: {
          early: { mastery: 0.6, momentum: 0.3, coins: 0.1 }, // Levels 1-20
          mid: { mastery: 0.5, momentum: 0.3, coins: 0.2 },   // Levels 21-60
          late: { mastery: 0.7, momentum: 0.2, coins: 0.1 }   // Levels 61-100
        },
        
        // Progressive Level Scaling
        levelScaling: {
          // Early levels (1-20): Quick wins
          early: { baseXP: 500, multiplier: 1.0, maxLevel: 20 },
          // Mid levels (21-60): Steady progression
          mid: { baseXP: 1000, multiplier: 1.1, maxLevel: 60 },
          // Late levels (61-100): Prestige progression
          late: { baseXP: 2000, multiplier: 1.2, maxLevel: 100 }
        },
        
        // Coin Economy
        coinEconomy: {
          earning: {
            task_completion: 10,     // Base coins per task
            quality_bonus: 5,        // High quality reflection
            focus_bonus: 3,          // No distractions
            novelty_bonus: 8,        // First time tackling subskill
            streak_bonus: 2,         // Daily streak
            banking_bonus: 10        // Daily review bonus
          },
          spending: {
            respec: 20,              // Weekly skill tree reset
            study_boost: 30,         // +20% XP for next session
            focus_mode: 25,          // 2-hour distraction-free mode
            cosmetic: 15             // Theme unlocks
          }
        },
        
        // Banking System
        banking: {
          risk: {
            missBankingDays: 2,      // Days before losing unbanked XP
            lossRate: 0.2,           // 20% loss of unbanked XP
            recoveryRate: 0.5        // 50% recovery by doing review
          },
          rewards: {
            baseCoins: 10,           // Base coins for banking
            qualityMultiplier: 1.5,  // Quality reflection bonus
            streakBonus: 2           // Streak bonus coins
          }
        },
        
        // Mastery Evidence Requirements
        mastery: {
          evidenceTypes: ['quiz', 'problem_set', 'retrieval_practice', 'project', 'exam'],
          levelThresholds: {
            novice: 0,       // 0-100 XP
            apprentice: 100, // 100-300 XP
            proficient: 300, // 300-600 XP
            advanced: 600,   // 600-1000 XP
            expert: 1000     // 1000+ XP
          },
          unlockRequirements: {
            'Error Pattern Analyzer': { 
              subject: 'math', 
              requirements: { problem_sets: 3, accuracy: 80, time_bonus: true },
              cost: 50 
            },
            'Data Clinic': { 
              subject: 'economics', 
              requirements: { projects: 2, complexity: 'high' },
              cost: 75 
            },
            'Code Kata Timer': { 
              subject: 'programming', 
              requirements: { exercises: 10, time_bonus: true },
              cost: 60 
            }
          }
        }
      };

      // ================== BLENDED PROGRESSION SYSTEM ==================
      
      // 1. COMPETENCY-BASED PROGRESSION SYSTEM
      const COMPETENCY_SYSTEM = {
        // Evidence requirements for each skill level
        evidenceTypes: {
          'problem_solving': {
            name: 'Problem Solving',
            description: 'Demonstrate ability to solve novel problems',
            weight: 1.0,
            examples: ['Complete 5 challenging problems', 'Solve real-world application', 'Debug complex code']
          },
          'explanation': {
            name: 'Explanation',
            description: 'Explain concepts clearly to others',
            weight: 0.8,
            examples: ['Teach concept to peer', 'Write clear documentation', 'Create tutorial']
          },
          'application': {
            name: 'Application',
            description: 'Apply knowledge in new contexts',
            weight: 1.2,
            examples: ['Build project using skill', 'Apply to different domain', 'Create original work']
          },
          'assessment': {
            name: 'Assessment',
            description: 'Pass rigorous evaluation',
            weight: 1.0,
            examples: ['Pass comprehensive test', 'Complete peer review', 'Submit portfolio']
          },
          'reflection': {
            name: 'Reflection',
            description: 'Analyze and improve learning process',
            weight: 0.6,
            examples: ['Write learning journal', 'Identify knowledge gaps', 'Plan next steps']
          }
        },

        // Mastery thresholds (90%+ required)
        masteryThresholds: {
          'novice': { required: 0.7, evidence_types: 2 },
          'apprentice': { required: 0.8, evidence_types: 3 },
          'proficient': { required: 0.85, evidence_types: 4 },
          'advanced': { required: 0.9, evidence_types: 5 },
          'expert': { required: 0.95, evidence_types: 5 }
        },

        // Adaptive difficulty scaling
        difficultyLevels: {
          'too_easy': { threshold: 0.95, adjustment: 1.3, message: 'Increasing challenge level' },
          'optimal': { threshold: 0.85, adjustment: 1.0, message: 'Perfect difficulty' },
          'challenging': { threshold: 0.7, adjustment: 0.8, message: 'Slightly reducing difficulty' },
          'too_hard': { threshold: 0.5, adjustment: 0.6, message: 'Significantly reducing difficulty' }
        }
      };

      // 2. MASTERY LEARNING SYSTEM
      const MASTERY_SYSTEM = {
        // Bloom's Taxonomy progression levels
        bloomLevels: {
          'remember': {
            name: 'Remember',
            description: 'Recall facts and basic concepts',
            evidence_required: ['recall_facts', 'define_terms'],
            mastery_threshold: 0.9
          },
          'understand': {
            name: 'Understand',
            description: 'Explain ideas or concepts',
            evidence_required: ['explain_concepts', 'summarize_ideas'],
            mastery_threshold: 0.9
          },
          'apply': {
            name: 'Apply',
            description: 'Use information in new situations',
            evidence_required: ['solve_problems', 'use_procedures'],
            mastery_threshold: 0.9
          },
          'analyze': {
            name: 'Analyze',
            description: 'Draw connections among ideas',
            evidence_required: ['compare_contrast', 'identify_patterns'],
            mastery_threshold: 0.9
          },
          'evaluate': {
            name: 'Evaluate',
            description: 'Justify a stand or decision',
            evidence_required: ['critique_arguments', 'make_judgments'],
            mastery_threshold: 0.9
          },
          'create': {
            name: 'Create',
            description: 'Produce new or original work',
            evidence_required: ['design_solutions', 'create_original_work'],
            mastery_threshold: 0.9
          }
        },

        // Spaced repetition for skill maintenance
        spacedRepetition: {
          intervals: [1, 3, 7, 14, 30, 90], // days
          decayRate: 0.1, // 10% per interval
          reviewThreshold: 0.8, // Trigger review when below 80%
          masteryBonus: 0.05 // 5% bonus for maintaining mastery
        }
      };

      // 3. ADAPTIVE DIFFICULTY SYSTEM
      const ADAPTIVE_SYSTEM = {
        // Zone of Proximal Development (ZPD) calculation
        calculateZPD: (currentAbility, performanceHistory) => {
          const avgPerformance = performanceHistory.reduce((sum, p) => sum + p.score, 0) / performanceHistory.length;
          const consistency = 1 - (Math.max(...performanceHistory.map(p => p.score)) - Math.min(...performanceHistory.map(p => p.score)));
          
          // Optimal challenge is just beyond current ability
          const optimalDifficulty = currentAbility + (0.1 * consistency);
          
          return {
            minDifficulty: Math.max(0.3, currentAbility - 0.1),
            optimalDifficulty: Math.min(1.0, optimalDifficulty),
            maxDifficulty: Math.min(1.0, currentAbility + 0.3),
            confidence: consistency
          };
        },

        // Performance tracking
        trackPerformance: (task, score, timeSpent, estimatedTime) => {
          const efficiency = estimatedTime / timeSpent;
          const difficulty = task.difficulty || 0.5;
          
          return {
            score,
            efficiency,
            difficulty,
            timestamp: Date.now(),
            taskId: task.id,
            subject: task.subject,
            subSkill: task.subSkill
          };
        },

        // Adaptive content recommendation
        recommendContent: (userProfile, availableContent) => {
          const zpd = ADAPTIVE_SYSTEM.calculateZPD(userProfile.currentAbility, userProfile.performanceHistory);
          
          return availableContent.filter(content => 
            content.difficulty >= zpd.minDifficulty && 
            content.difficulty <= zpd.maxDifficulty
          ).sort((a, b) => {
            // Prioritize content closest to optimal difficulty
            const aDistance = Math.abs(a.difficulty - zpd.optimalDifficulty);
            const bDistance = Math.abs(b.difficulty - zpd.optimalDifficulty);
            return aDistance - bDistance;
          });
        }
      };

      // 4. ENHANCED GAMIFICATION SYSTEM
      const GAMIFICATION_SYSTEM = {
        // Skill mastery tiers with real-world validation
        masteryTiers: {
          'novice': {
            name: 'Novice',
            description: 'Basic understanding and application',
            requirements: {
              bloom_levels: ['remember', 'understand'],
              evidence_count: 2,
              peer_reviews: 0,
              projects: 0
            },
            unlocks: ['Basic tools', 'Simple challenges', 'Community access']
          },
          'apprentice': {
            name: 'Apprentice',
            description: 'Can apply knowledge with guidance',
            requirements: {
              bloom_levels: ['remember', 'understand', 'apply'],
              evidence_count: 4,
              peer_reviews: 1,
              projects: 1
            },
            unlocks: ['Intermediate tools', 'Mentor access', 'Study groups']
          },
          'proficient': {
            name: 'Proficient',
            description: 'Independent application and analysis',
            requirements: {
              bloom_levels: ['remember', 'understand', 'apply', 'analyze'],
              evidence_count: 6,
              peer_reviews: 2,
              projects: 2
            },
            unlocks: ['Advanced tools', 'Teaching opportunities', 'Research access']
          },
          'advanced': {
            name: 'Advanced',
            description: 'Can evaluate and create original work',
            requirements: {
              bloom_levels: ['remember', 'understand', 'apply', 'analyze', 'evaluate'],
              evidence_count: 8,
              peer_reviews: 3,
              projects: 3
            },
            unlocks: ['Expert tools', 'Mentoring others', 'Conference presentations']
          },
          'expert': {
            name: 'Expert',
            description: 'Mastery with original contributions',
            requirements: {
              bloom_levels: ['remember', 'understand', 'apply', 'analyze', 'evaluate', 'create'],
              evidence_count: 10,
              peer_reviews: 5,
              projects: 5
            },
            unlocks: ['All tools', 'Expert status', 'Research collaboration']
          }
        },

        // Achievement system with meaningful unlocks
        achievements: {
          'first_derivative': {
            name: 'First Derivative',
            description: 'Master basic differentiation',
            requirements: {
              skill: 'differential_calculus',
              tier: 'proficient',
              evidence: ['problem_solving', 'explanation']
            },
            unlocks: ['Integration tools', 'Optimization challenges'],
            icon: '📈'
          },
          'data_structures_master': {
            name: 'Data Structures Master',
            description: 'Master fundamental data structures',
            requirements: {
              skill: 'data_structures',
              tier: 'advanced',
              evidence: ['problem_solving', 'application', 'assessment']
            },
            unlocks: ['Algorithm challenges', 'System design tools'],
            icon: '🏗️'
          },
          'research_paper': {
            name: 'Research Contributor',
            description: 'Complete original research work',
            requirements: {
              skill: 'research_methods',
              tier: 'expert',
              evidence: ['application', 'reflection', 'assessment']
            },
            unlocks: ['Advanced research tools', 'Peer review access'],
            icon: '📚'
          }
        },

        // Learning paths with cross-skill synergies
        learningPaths: {
          'mathematician': {
            name: 'The Mathematician',
            description: 'Pure mathematical reasoning and proof',
            skills: ['calculus', 'linear_algebra', 'real_analysis', 'abstract_algebra'],
            synergies: {
              'calculus + linear_algebra': 'Multivariable calculus',
              'real_analysis + abstract_algebra': 'Advanced mathematical structures'
            },
            final_unlock: 'Mathematical research collaboration'
          },
          'data_scientist': {
            name: 'The Data Scientist',
            description: 'Statistical analysis and machine learning',
            skills: ['statistics', 'programming', 'machine_learning', 'data_visualization'],
            synergies: {
              'statistics + programming': 'Statistical computing',
              'machine_learning + data_visualization': 'ML model interpretation'
            },
            final_unlock: 'Industry data science projects'
          },
          'researcher': {
            name: 'The Researcher',
            description: 'Academic research and discovery',
            skills: ['research_methods', 'critical_thinking', 'writing', 'presentation'],
            synergies: {
              'research_methods + critical_thinking': 'Rigorous analysis',
              'writing + presentation': 'Effective communication'
            },
            final_unlock: 'Academic publication opportunities'
          }
        }
      };

      // 5. RESEARCH-BASED LEARNING SYSTEM
      const RESEARCH_SYSTEM = {
        // Cognitive load optimization
        cognitiveLoad: {
          intrinsic: {
            // Difficulty inherent to the material
            'arithmetic': 0.3,
            'algebra': 0.5,
            'calculus': 0.7,
            'real_analysis': 0.9
          },
          extraneous: {
            // Poor design that adds unnecessary difficulty
            'confusing_interface': 0.2,
            'unclear_instructions': 0.3,
            'irrelevant_information': 0.1
          },
          germane: {
            // Effort devoted to learning and schema construction
            'active_processing': -0.2, // Reduces load
            'pattern_recognition': -0.3,
            'metacognitive_reflection': -0.1
          }
        },

        // Learning style adaptation
        learningStyles: {
          'visual': {
            preferences: ['diagrams', 'charts', 'videos', 'infographics'],
            adaptations: {
              'problem_solving': 'Visual problem decomposition',
              'explanation': 'Concept maps and flowcharts'
            }
          },
          'auditory': {
            preferences: ['discussions', 'lectures', 'podcasts', 'explanations'],
            adaptations: {
              'problem_solving': 'Verbal reasoning aloud',
              'explanation': 'Oral presentations and discussions'
            }
          },
          'kinesthetic': {
            preferences: ['hands_on', 'projects', 'experiments', 'building'],
            adaptations: {
              'problem_solving': 'Physical modeling and manipulation',
              'explanation': 'Interactive demonstrations'
            }
          },
          'reading_writing': {
            preferences: ['text', 'notes', 'writing', 'reading'],
            adaptations: {
              'problem_solving': 'Written step-by-step solutions',
              'explanation': 'Detailed written explanations'
            }
          }
        },

        // Metacognitive strategies
        metacognition: {
          strategies: {
            'planning': {
              name: 'Planning',
              description: 'Set goals and strategies before learning',
              prompts: ['What do I want to achieve?', 'How will I approach this?', 'What resources do I need?']
            },
            'monitoring': {
              name: 'Monitoring',
              description: 'Track understanding during learning',
              prompts: ['Do I understand this?', 'Am I making progress?', 'What is confusing?']
            },
            'evaluating': {
              name: 'Evaluating',
              description: 'Assess learning after completion',
              prompts: ['What did I learn?', 'What was difficult?', 'How can I improve?']
            }
          }
        }
      };

      // ================== BLENDED PROGRESSION ENGINE ==================
      
      // Core engine that integrates all five systems
      const BLENDED_PROGRESSION_ENGINE = {
        // Main progression calculation
        calculateProgression: (task, userProfile, performanceData) => {
          // 1. Competency-based evidence collection
          const evidence = this.collectEvidence(task, performanceData);
          
          // 2. Mastery learning assessment
          const masteryLevel = this.assessMastery(task, evidence, userProfile);
          
          // 3. Adaptive difficulty adjustment
          const adaptedDifficulty = this.adjustDifficulty(userProfile, performanceData);
          
          // 4. Gamification rewards
          const gamificationRewards = this.calculateGamificationRewards(task, masteryLevel, userProfile);
          
          // 5. Research-based optimization
          const optimizedLearning = this.optimizeLearningExperience(task, userProfile);
          
          return {
            evidence,
            masteryLevel,
            adaptedDifficulty,
            gamificationRewards,
            optimizedLearning,
            progression: this.calculateOverallProgression(evidence, masteryLevel, gamificationRewards)
          };
        },

        // Evidence collection system
        collectEvidence: (task, performanceData) => {
          const evidence = {
            problem_solving: this.assessProblemSolving(task, performanceData),
            explanation: this.assessExplanation(task, performanceData),
            application: this.assessApplication(task, performanceData),
            assessment: this.assessAssessment(task, performanceData),
            reflection: this.assessReflection(task, performanceData)
          };

          // Calculate weighted evidence score
          let totalScore = 0;
          let totalWeight = 0;
          
          Object.entries(evidence).forEach(([type, score]) => {
            const weight = COMPETENCY_SYSTEM.evidenceTypes[type].weight;
            totalScore += score * weight;
            totalWeight += weight;
          });

          return {
            ...evidence,
            overallScore: totalWeight > 0 ? totalScore / totalWeight : 0,
            timestamp: Date.now(),
            taskId: task.id
          };
        },

        // Mastery assessment using Bloom's taxonomy
        assessMastery: (task, evidence, userProfile) => {
          const bloomProgress = {};
          
          // Assess each Bloom's level
          Object.entries(MASTERY_SYSTEM.bloomLevels).forEach(([level, config]) => {
            const levelEvidence = this.getBloomEvidence(evidence, level);
            const masteryScore = this.calculateBloomMastery(levelEvidence, config.mastery_threshold);
            
            bloomProgress[level] = {
              score: masteryScore,
              mastered: masteryScore >= config.mastery_threshold,
              evidence: levelEvidence
            };
          });

          // Determine overall mastery tier
          const masteredLevels = Object.values(bloomProgress).filter(level => level.mastered).length;
          const totalLevels = Object.keys(bloomProgress).length;
          const masteryPercentage = masteredLevels / totalLevels;

          let currentTier = 'novice';
          Object.entries(COMPETENCY_SYSTEM.masteryThresholds).forEach(([tier, threshold]) => {
            if (masteryPercentage >= threshold.required) {
              currentTier = tier;
            }
          });

          return {
            bloomProgress,
            currentTier,
            masteryPercentage,
            nextTier: this.getNextTier(currentTier),
            progressToNext: this.calculateProgressToNext(currentTier, masteryPercentage)
          };
        },

        // Adaptive difficulty adjustment
        adjustDifficulty: (userProfile, performanceData) => {
          const recentPerformance = performanceData.slice(-10); // Last 10 tasks
          const zpd = ADAPTIVE_SYSTEM.calculateZPD(userProfile.currentAbility, recentPerformance);
          
          // Determine difficulty adjustment
          const avgScore = recentPerformance.reduce((sum, p) => sum + p.score, 0) / recentPerformance.length;
          const difficultyLevel = this.classifyDifficulty(avgScore);
          
          return {
            currentAbility: userProfile.currentAbility,
            zpd,
            difficultyLevel,
            recommendedAdjustment: COMPETENCY_SYSTEM.difficultyLevels[difficultyLevel],
            nextTaskDifficulty: this.calculateNextTaskDifficulty(zpd, difficultyLevel)
          };
        },

        // Gamification rewards calculation
        calculateGamificationRewards: (task, masteryLevel, userProfile) => {
          const rewards = {
            achievements: [],
            unlocks: [],
            skillPoints: 0,
            coins: 0,
            experience: 0
          };

          // Check for new achievements
          Object.entries(GAMIFICATION_SYSTEM.achievements).forEach(([id, achievement]) => {
            if (this.checkAchievementRequirements(achievement, task, masteryLevel, userProfile)) {
              rewards.achievements.push(achievement);
              rewards.unlocks.push(...achievement.unlocks);
            }
          });

          // Calculate skill progression
          const skillProgress = this.calculateSkillProgress(task, masteryLevel);
          rewards.skillPoints = skillProgress.points;
          rewards.coins = skillProgress.coins;
          rewards.experience = skillProgress.experience;

          // Check for tier advancement
          if (masteryLevel.progressToNext >= 1.0) {
            const nextTier = masteryLevel.nextTier;
            const tierRewards = GAMIFICATION_SYSTEM.masteryTiers[nextTier];
            rewards.unlocks.push(...tierRewards.unlocks);
            rewards.coins += 50; // Tier advancement bonus
          }

          return rewards;
        },

        // Learning experience optimization
        optimizeLearningExperience: (task, userProfile) => {
          // Cognitive load optimization
          const cognitiveLoad = this.calculateCognitiveLoad(task, userProfile);
          
          // Learning style adaptation
          const learningStyle = userProfile.learningStyle || 'visual';
          const adaptations = RESEARCH_SYSTEM.learningStyles[learningStyle];
          
          // Metacognitive prompts
          const metacognitivePrompts = this.generateMetacognitivePrompts(task, userProfile);
          
          // Spaced repetition scheduling
          const reviewSchedule = this.calculateReviewSchedule(task, userProfile);

          return {
            cognitiveLoad,
            learningStyle,
            adaptations,
            metacognitivePrompts,
            reviewSchedule,
            recommendations: this.generateLearningRecommendations(task, cognitiveLoad, adaptations)
          };
        },

        // Helper methods
        assessProblemSolving: (task, performanceData) => {
          // Assess problem-solving ability based on task completion and accuracy
          const accuracy = performanceData.accuracy || 0.8;
          const timeEfficiency = performanceData.timeEfficiency || 1.0;
          const complexity = task.difficulty || 0.5;
          
          return Math.min(1.0, (accuracy * 0.6 + timeEfficiency * 0.2 + complexity * 0.2));
        },

        assessExplanation: (task, performanceData) => {
          // Assess explanation ability (requires user input or peer review)
          return performanceData.explanationScore || 0.7;
        },

        assessApplication: (task, performanceData) => {
          // Assess application in new contexts
          return performanceData.applicationScore || 0.6;
        },

        assessAssessment: (task, performanceData) => {
          // Assess performance on formal assessments
          return performanceData.assessmentScore || 0.8;
        },

        assessReflection: (task, performanceData) => {
          // Assess metacognitive reflection
          return performanceData.reflectionScore || 0.5;
        },

        getBloomEvidence: (evidence, bloomLevel) => {
          // Map evidence types to Bloom's taxonomy levels
          const mapping = {
            'remember': ['assessment'],
            'understand': ['explanation', 'assessment'],
            'apply': ['problem_solving', 'application'],
            'analyze': ['problem_solving', 'explanation'],
            'evaluate': ['reflection', 'explanation'],
            'create': ['application', 'problem_solving']
          };

          const relevantEvidence = mapping[bloomLevel] || [];
          return relevantEvidence.map(type => evidence[type] || 0);
        },

        calculateBloomMastery: (evidence, threshold) => {
          const avgEvidence = evidence.reduce((sum, score) => sum + score, 0) / evidence.length;
          return Math.min(1.0, avgEvidence / threshold);
        },

        classifyDifficulty: (avgScore) => {
          if (avgScore >= 0.95) return 'too_easy';
          if (avgScore >= 0.85) return 'optimal';
          if (avgScore >= 0.7) return 'challenging';
          return 'too_hard';
        },

        calculateNextTaskDifficulty: (zpd, difficultyLevel) => {
          const adjustment = COMPETENCY_SYSTEM.difficultyLevels[difficultyLevel].adjustment;
          return Math.min(1.0, Math.max(0.1, zpd.optimalDifficulty * adjustment));
        },

        checkAchievementRequirements: (achievement, task, masteryLevel, userProfile) => {
          // Check if achievement requirements are met
          const requirements = achievement.requirements;
          
          return (
            requirements.skill === task.subSkill &&
            masteryLevel.currentTier === requirements.tier &&
            this.hasRequiredEvidence(requirements.evidence, masteryLevel)
          );
        },

        hasRequiredEvidence: (requiredEvidence, masteryLevel) => {
          return requiredEvidence.every(evidenceType => 
            masteryLevel.bloomProgress[evidenceType]?.mastered || false
          );
        },

        calculateSkillProgress: (task, masteryLevel) => {
          const basePoints = 10;
          const tierMultiplier = this.getTierMultiplier(masteryLevel.currentTier);
          const masteryBonus = masteryLevel.masteryPercentage * 5;
          
          return {
            points: Math.round(basePoints * tierMultiplier),
            coins: Math.round(basePoints * tierMultiplier * 0.5),
            experience: Math.round(basePoints * tierMultiplier + masteryBonus)
          };
        },

        getTierMultiplier: (tier) => {
          const multipliers = {
            'novice': 1.0,
            'apprentice': 1.2,
            'proficient': 1.5,
            'advanced': 2.0,
            'expert': 3.0
          };
          return multipliers[tier] || 1.0;
        },

        getNextTier: (currentTier) => {
          const tiers = ['novice', 'apprentice', 'proficient', 'advanced', 'expert'];
          const currentIndex = tiers.indexOf(currentTier);
          return currentIndex < tiers.length - 1 ? tiers[currentIndex + 1] : null;
        },

        calculateProgressToNext: (currentTier, masteryPercentage) => {
          const thresholds = COMPETENCY_SYSTEM.masteryThresholds;
          const currentThreshold = thresholds[currentTier].required;
          const nextTier = this.getNextTier(currentTier);
          
          if (!nextTier) return 1.0; // Already at max tier
          
          const nextThreshold = thresholds[nextTier].required;
          const progress = (masteryPercentage - currentThreshold) / (nextThreshold - currentThreshold);
          return Math.max(0, Math.min(1, progress));
        },

        calculateCognitiveLoad: (task, userProfile) => {
          const intrinsic = RESEARCH_SYSTEM.cognitiveLoad.intrinsic[task.subject] || 0.5;
          const extraneous = this.calculateExtraneousLoad(task);
          const germane = this.calculateGermaneLoad(userProfile);
          
          return {
            intrinsic,
            extraneous,
            germane,
            total: intrinsic + extraneous + germane,
            optimal: intrinsic + germane, // Target load
            overload: intrinsic + extraneous + germane > 0.8
          };
        },

        calculateExtraneousLoad: (task) => {
          let load = 0;
          if (task.interfaceComplexity) load += 0.1;
          if (task.unclearInstructions) load += 0.2;
          if (task.irrelevantInfo) load += 0.1;
          return load;
        },

        calculateGermaneLoad: (userProfile) => {
          let load = 0;
          if (userProfile.activeProcessing) load -= 0.2;
          if (userProfile.patternRecognition) load -= 0.3;
          if (userProfile.metacognitiveReflection) load -= 0.1;
          return load;
        },

        generateMetacognitivePrompts: (task, userProfile) => {
          const strategy = RESEARCH_SYSTEM.metacognition.strategies[userProfile.metacognitiveStrategy] || 
                          RESEARCH_SYSTEM.metacognition.strategies.planning;
          
          return {
            preTask: strategy.prompts.slice(0, 2),
            duringTask: strategy.prompts.slice(1, 3),
            postTask: strategy.prompts.slice(2)
          };
        },

        calculateReviewSchedule: (task, userProfile) => {
          const intervals = MASTERY_SYSTEM.spacedRepetition.intervals;
          const currentMastery = userProfile.skillMastery[task.subSkill] || 0.5;
          
          // Calculate next review based on current mastery
          let nextReview = intervals[0]; // Start with 1 day
          for (let i = 0; i < intervals.length; i++) {
            if (currentMastery >= 0.8 + (i * 0.05)) {
              nextReview = intervals[i];
            } else {
              break;
            }
          }
          
          return {
            nextReview: Date.now() + (nextReview * 24 * 60 * 60 * 1000),
            interval: nextReview,
            masteryDecay: currentMastery * (1 - MASTERY_SYSTEM.spacedRepetition.decayRate)
          };
        },

        generateLearningRecommendations: (task, cognitiveLoad, adaptations) => {
          const recommendations = [];
          
          if (cognitiveLoad.overload) {
            recommendations.push('Consider breaking this task into smaller chunks');
          }
          
          if (cognitiveLoad.extraneous > 0.2) {
            recommendations.push('Simplify the interface or instructions');
          }
          
          // Add learning style specific recommendations
          recommendations.push(...adaptations.preferences.map(pref => 
            `Try incorporating ${pref} into your learning`
          ));
          
          return recommendations;
        },

        calculateOverallProgression: (evidence, masteryLevel, gamificationRewards) => {
          return {
            evidenceScore: evidence.overallScore,
            masteryTier: masteryLevel.currentTier,
            masteryPercentage: masteryLevel.masteryPercentage,
            achievements: gamificationRewards.achievements.length,
            unlocks: gamificationRewards.unlocks.length,
            skillPoints: gamificationRewards.skillPoints,
            coins: gamificationRewards.coins,
            experience: gamificationRewards.experience,
            timestamp: Date.now()
          };
        }
      };

      // ================== ML-Enhanced XP System ==================
      
      // Objective Academic Knowledge Database
      const ACADEMIC_DIFFICULTY_MATRIX = {
        'Math': {
          'Arithmetic Foundations': { baseDifficulty: 1.0, cognitiveLoad: 'low' },
          'Algebra I': { baseDifficulty: 1.2, cognitiveLoad: 'medium' },
          'Algebra II': { baseDifficulty: 1.4, cognitiveLoad: 'medium-high' },
          'Trigonometry': { baseDifficulty: 1.6, cognitiveLoad: 'high' },
          'Calculus': { baseDifficulty: 2.0, cognitiveLoad: 'very-high' },
          'Differential Equations': { baseDifficulty: 2.5, cognitiveLoad: 'very-high' },
          'Linear Algebra': { baseDifficulty: 2.2, cognitiveLoad: 'very-high' },
          'Real Analysis': { baseDifficulty: 3.0, cognitiveLoad: 'extremely-high' },
          'Statistics': { baseDifficulty: 1.8, cognitiveLoad: 'high' },
          'Probability': { baseDifficulty: 2.0, cognitiveLoad: 'very-high' }
        },
        'Programming': {
          'Basic Syntax': { baseDifficulty: 1.0, cognitiveLoad: 'low' },
          'Control Structures': { baseDifficulty: 1.3, cognitiveLoad: 'medium' },
          'Data Structures': { baseDifficulty: 1.8, cognitiveLoad: 'high' },
          'Algorithms': { baseDifficulty: 2.2, cognitiveLoad: 'very-high' },
          'System Design': { baseDifficulty: 2.8, cognitiveLoad: 'extremely-high' },
          'Machine Learning': { baseDifficulty: 2.5, cognitiveLoad: 'very-high' },
          'Web Development': { baseDifficulty: 1.6, cognitiveLoad: 'high' },
          'Database Design': { baseDifficulty: 1.9, cognitiveLoad: 'high' }
        },
        'Economics': {
          'Microeconomics': { baseDifficulty: 1.4, cognitiveLoad: 'medium-high' },
          'Macroeconomics': { baseDifficulty: 1.6, cognitiveLoad: 'high' },
          'Econometrics': { baseDifficulty: 2.2, cognitiveLoad: 'very-high' },
          'Game Theory': { baseDifficulty: 2.0, cognitiveLoad: 'very-high' },
          'Financial Economics': { baseDifficulty: 1.8, cognitiveLoad: 'high' },
          'Behavioral Economics': { baseDifficulty: 1.7, cognitiveLoad: 'high' }
        },
        'History': {
          'Ancient History': { baseDifficulty: 1.2, cognitiveLoad: 'medium' },
          'Medieval History': { baseDifficulty: 1.3, cognitiveLoad: 'medium' },
          'Modern History': { baseDifficulty: 1.4, cognitiveLoad: 'medium-high' },
          'Economic History': { baseDifficulty: 1.6, cognitiveLoad: 'high' },
          'Historiography': { baseDifficulty: 1.8, cognitiveLoad: 'high' },
          'Research Methods': { baseDifficulty: 1.9, cognitiveLoad: 'high' }
        }
      };

      // Task Type Complexity Database (Educational Research)
      const TASK_COMPLEXITY_DATABASE = {
        'Passive Learning': {
          'Lecture': { cognitiveLoad: 0.7, timeMultiplier: 1.0, retention: 0.3 },
          'Reading': { cognitiveLoad: 0.8, timeMultiplier: 1.1, retention: 0.5 },
          'Video Tutorial': { cognitiveLoad: 0.9, timeMultiplier: 1.2, retention: 0.4 },
          'Documentation': { cognitiveLoad: 0.6, timeMultiplier: 1.0, retention: 0.4 }
        },
        'Active Learning': {
          'Practice Problems': { cognitiveLoad: 1.2, timeMultiplier: 1.3, retention: 0.7 },
          'Homework Set': { cognitiveLoad: 1.5, timeMultiplier: 1.6, retention: 0.8 },
          'Problem Solving': { cognitiveLoad: 1.8, timeMultiplier: 1.8, retention: 0.9 },
          'Project Work': { cognitiveLoad: 2.0, timeMultiplier: 2.0, retention: 0.95 },
          'Exercise': { cognitiveLoad: 1.1, timeMultiplier: 1.2, retention: 0.6 },
          'Assignment': { cognitiveLoad: 1.6, timeMultiplier: 1.7, retention: 0.85 }
        },
        'Assessment': {
          'Quiz': { cognitiveLoad: 1.4, timeMultiplier: 1.2, retention: 0.6 },
          'Exam Prep': { cognitiveLoad: 1.8, timeMultiplier: 1.6, retention: 0.7 },
          'Test': { cognitiveLoad: 2.2, timeMultiplier: 1.8, retention: 0.8 },
          'Final Exam': { cognitiveLoad: 2.5, timeMultiplier: 2.2, retention: 0.9 }
        },
        'Creative Work': {
          'Essay': { cognitiveLoad: 1.7, timeMultiplier: 1.9, retention: 0.8 },
          'Research Paper': { cognitiveLoad: 2.0, timeMultiplier: 2.1, retention: 0.9 },
          'Presentation': { cognitiveLoad: 1.6, timeMultiplier: 1.8, retention: 0.75 },
          'Portfolio': { cognitiveLoad: 1.9, timeMultiplier: 2.0, retention: 0.85 }
        }
      };

      // Prerequisite Knowledge Mapping
      const PREREQUISITE_MAP = {
        'Differential Equations': {
          prerequisites: ['Calculus', 'Linear Algebra'],
          difficultyMultiplier: 1.3,
          knowledgeGaps: { 'Calculus': 0.8, 'Linear Algebra': 0.6 }
        },
        'Machine Learning': {
          prerequisites: ['Statistics', 'Linear Algebra', 'Programming'],
          difficultyMultiplier: 1.5,
          knowledgeGaps: { 'Statistics': 0.7, 'Linear Algebra': 0.8, 'Programming': 0.6 }
        },
        'Econometrics': {
          prerequisites: ['Statistics', 'Macroeconomics'],
          difficultyMultiplier: 1.4,
          knowledgeGaps: { 'Statistics': 0.9, 'Macroeconomics': 0.7 }
        },
        'Real Analysis': {
          prerequisites: ['Calculus', 'Proof Techniques'],
          difficultyMultiplier: 1.6,
          knowledgeGaps: { 'Calculus': 0.9, 'Proof Techniques': 0.8 }
        }
      };

      // Research-Based Foundation Values (Academic Standards)
      const RESEARCH_FOUNDATION = {
        // Time-based learning research (Bloom's Taxonomy + cognitive load theory)
        timeMultipliers: {
          'recognition': 0.8,      // Simple recognition tasks
          'comprehension': 1.0,    // Understanding concepts
          'application': 1.3,      // Applying knowledge
          'analysis': 1.6,         // Breaking down complex problems
          'synthesis': 1.8,        // Creating new solutions
          'evaluation': 2.0        // Critical assessment
        },
        
        // Subject complexity weights (based on cognitive demand research)
        subjectComplexity: {
          'Math': 1.4,           // High cognitive load
          'Programming': 1.5,    // Very high cognitive load
          'Economics': 1.2,      // Medium-high cognitive load
          'History': 1.1,        // Medium cognitive load
          'Language': 1.0,       // Baseline
          'General': 1.0         // Baseline
        },
        
        // Task type difficulty (based on educational research)
        taskTypeDifficulty: {
          'Lecture': 0.7,        // Passive learning
          'Reading': 0.8,        // Active reading
          'Practice': 1.0,       // Basic practice
          'Exercise': 1.1,       // Guided practice
          'Problem Set': 1.3,    // Independent problem solving
          'Assignment': 1.5,     // Extended work
          'Project': 1.8,        // Complex integration
          'Exam Prep': 1.6,      // High-stakes preparation
          'Quiz Prep': 1.2,      // Quick preparation
          'Test': 2.0,           // Assessment
          'Tutorial': 0.9,       // Guided instruction
          'Review': 0.6,         // Reinforcement
          'Vocabulary': 0.5,     // Memorization
          'Grammar': 0.8,        // Pattern recognition
          'Conversation': 1.2,   // Active communication
          'Writing': 1.4,        // Creative expression
          'Workout': 1.0,        // Physical activity
          'Cardio': 0.9,         // Endurance
          'Strength': 1.1,       // Resistance training
          'Flexibility': 0.7,    // Mobility
          'Sports': 1.2          // Competitive activity
        }
      };

      // Auto XP Calculation System
      const XP_MATRIX = {
        'CS1010E': { 
          'Practice': 20, 'Assignment': 50, 'Exam Prep': 80, 'Project': 100, 'Lecture': 15, 'Tutorial': 25
        },
        'MA1301': { 
          'Exercise': 15, 'Problem Set': 40, 'Quiz Prep': 60, 'Test': 100, 'Lecture': 12, 'Tutorial': 20
        },
        'General': { 
          'Quick Task': 10, 'Medium Task': 25, 'Long Task': 50, 'Project': 75, 'Study': 20, 'Review': 15
        },
        'Training': { 
          'Workout': 30, 'Cardio': 25, 'Strength': 35, 'Flexibility': 15, 'Sports': 40
        },
        'Language': { 
          'Vocabulary': 10, 'Grammar': 15, 'Conversation': 25, 'Reading': 20, 'Writing': 30
        }
      };

      // ML Learning System
      const ML_SYSTEM = {
        // Pattern recognition for user behavior
        analyzePatterns(userHistory) {
          const patterns = {
            categoryPreferences: {},
            difficultyTendencies: {},
            timeEfficiency: {},
            completionRates: {},
            adjustmentHistory: []
          };

          // Analyze category patterns
          userHistory.forEach(entry => {
            if (entry.category) {
              patterns.categoryPreferences[entry.category] = 
                (patterns.categoryPreferences[entry.category] || 0) + 1;
            }
          });

          // Analyze difficulty tendencies
          userHistory.forEach(entry => {
            if (entry.difficulty) {
              patterns.difficultyTendencies[entry.difficulty] = 
                (patterns.difficultyTendencies[entry.difficulty] || 0) + 1;
            }
          });

          // Analyze time efficiency (estimated vs actual)
          userHistory.forEach(entry => {
            if (entry.estimateMin && entry.actualMin) {
              const efficiency = entry.actualMin / entry.estimateMin;
              const key = `${entry.category}-${entry.taskType}`;
              if (!patterns.timeEfficiency[key]) {
                patterns.timeEfficiency[key] = [];
              }
              patterns.timeEfficiency[key].push(efficiency);
            }
          });

          // Calculate average efficiency per category/task type
          Object.keys(patterns.timeEfficiency).forEach(key => {
            const efficiencies = patterns.timeEfficiency[key];
            patterns.timeEfficiency[key] = {
              average: efficiencies.reduce((a, b) => a + b, 0) / efficiencies.length,
              count: efficiencies.length,
              consistency: 1 - (Math.max(...efficiencies) - Math.min(...efficiencies)) / Math.max(...efficiencies)
            };
          });

          return patterns;
        },

        // Learn from user adjustments
        learnFromAdjustments(adjustments, patterns) {
          const learning = {
            categoryBias: {},
            difficultyBias: {},
            timeBias: {},
            confidence: 0.5 // Start with moderate confidence
          };

          // Analyze adjustment patterns
          Object.entries(adjustments).forEach(([key, adjustment]) => {
            const [category, taskType, difficulty] = key.split('-');
            
            if (!learning.categoryBias[category]) {
              learning.categoryBias[category] = [];
            }
            learning.categoryBias[category].push(adjustment);

            if (!learning.difficultyBias[difficulty]) {
              learning.difficultyBias[difficulty] = [];
            }
            learning.difficultyBias[difficulty].push(adjustment);
          });

          // Calculate average biases
          Object.keys(learning.categoryBias).forEach(category => {
            const adjustments = learning.categoryBias[category];
            learning.categoryBias[category] = adjustments.reduce((a, b) => a + b, 0) / adjustments.length;
          });

          Object.keys(learning.difficultyBias).forEach(difficulty => {
            const adjustments = learning.difficultyBias[difficulty];
            learning.difficultyBias[difficulty] = adjustments.reduce((a, b) => a + b, 0) / adjustments.length;
          });

          // Calculate confidence based on consistency
          const allAdjustments = Object.values(adjustments);
          if (allAdjustments.length > 5) {
            const avgAdjustment = allAdjustments.reduce((a, b) => a + b, 0) / allAdjustments.length;
            const variance = allAdjustments.reduce((sum, adj) => sum + Math.pow(adj - avgAdjustment, 2), 0) / allAdjustments.length;
            learning.confidence = Math.max(0.3, Math.min(0.9, 1 - (variance / 0.5))); // Normalize variance
          }

          return learning;
        },

        // Predict optimal XP based on learned patterns
        predictOptimalXP(subject, subSkill, taskType, difficulty, estimatedTime, patterns, learning, userLevel = 5) {
          // Enhanced objective calculation using academic knowledge
          const objectiveXP = this.calculateObjectiveXP(subject, subSkill, taskType, difficulty, estimatedTime, userLevel);
          
          // Apply learned biases
          let adjustedXP = objectiveXP;
          
          // Category bias
          if (learning.categoryBias[subject]) {
            adjustedXP *= learning.categoryBias[subject];
          }
          
          // Difficulty bias
          if (learning.difficultyBias[difficulty]) {
            adjustedXP *= learning.difficultyBias[difficulty];
          }
          
          // Time efficiency adjustment
          const efficiencyKey = `${subject}-${taskType}`;
          if (patterns.timeEfficiency[efficiencyKey]) {
            const { average, consistency } = patterns.timeEfficiency[efficiencyKey];
            // If user consistently finishes early, boost XP; if consistently late, reduce
            const timeAdjustment = average < 1.0 ? 1.1 : (average > 1.2 ? 0.9 : 1.0);
            adjustedXP *= timeAdjustment;
          }
          
          // Apply confidence weighting
          const confidenceWeight = learning.confidence;
          const finalXP = Math.round(objectiveXP * confidenceWeight + adjustedXP * (1 - confidenceWeight));
          
          return {
            xp: Math.max(5, finalXP),
            confidence: learning.confidence,
            breakdown: {
              objective: objectiveXP,
              categoryBias: learning.categoryBias[subject] || 1.0,
              difficultyBias: learning.difficultyBias[difficulty] || 1.0,
              timeAdjustment: patterns.timeEfficiency[efficiencyKey]?.average || 1.0,
              confidence: confidenceWeight
            }
          };
        },

        // Enhanced objective XP calculation with academic knowledge
        calculateObjectiveXP(subject, subSkill, taskType, difficulty, estimatedTime, userLevel = 5) {
          // Get objective difficulty from academic knowledge base
          const topicDifficulty = ACADEMIC_DIFFICULTY_MATRIX[subject]?.[subSkill] || { baseDifficulty: 1.0 };
          
          // Find task complexity from educational research database
          let taskComplexity = null;
          for (const category of Object.keys(TASK_COMPLEXITY_DATABASE)) {
            if (TASK_COMPLEXITY_DATABASE[category][taskType]) {
              taskComplexity = TASK_COMPLEXITY_DATABASE[category][taskType];
              break;
            }
          }
          
          // Default task complexity if not found
          if (!taskComplexity) {
            taskComplexity = { cognitiveLoad: 1.0, timeMultiplier: 1.0, retention: 0.6 };
          }
          
          // Check for prerequisite knowledge gaps
          const prerequisite = PREREQUISITE_MAP[subSkill];
          let prerequisiteMultiplier = 1.0;
          if (prerequisite) {
            prerequisiteMultiplier = prerequisite.difficultyMultiplier;
          }
          
          // Calculate base XP using objective data
          let baseXP = 15; // Minimum meaningful XP
          
          // Apply objective difficulty multipliers
          baseXP *= topicDifficulty.baseDifficulty; // Academic difficulty
          baseXP *= taskComplexity.cognitiveLoad; // Task type complexity
          baseXP *= prerequisiteMultiplier; // Prerequisite knowledge gaps
          
          // Difficulty multiplier (user-selected)
          const difficultyMultiplier = DIFFICULTY_MULTIPLIERS[difficulty] || 1.0;
          baseXP *= difficultyMultiplier;
          
          // Time-based scaling (educational research)
          let timeMultiplier = 1.0;
          if (estimatedTime) {
            // More sophisticated time scaling based on task complexity
            const baseTimeMultiplier = Math.min(2.0, 1.0 + (estimatedTime / 60) * 0.5);
            timeMultiplier = baseTimeMultiplier * taskComplexity.timeMultiplier;
          }
          baseXP *= timeMultiplier;
          
          // User level adjustment (beginner vs advanced)
          const levelMultiplier = Math.max(0.5, Math.min(1.5, 1.0 + (userLevel - 5) * 0.1));
          baseXP *= levelMultiplier;
          
          return Math.max(5, Math.round(baseXP));
        },

        // Calculate foundation XP using research standards (legacy)
        calculateFoundationXP(category, taskType, difficulty, estimatedTime) {
          // Base XP from cognitive load theory
          const cognitiveLevel = RESEARCH_FOUNDATION.taskTypeDifficulty[taskType] || 1.0;
          const subjectWeight = RESEARCH_FOUNDATION.subjectComplexity[category] || 1.0;
          
          // Time-based multiplier (diminishing returns for very long tasks)
          let timeMultiplier = 1.0;
          if (estimatedTime) {
            if (estimatedTime <= 15) timeMultiplier = 0.7;
            else if (estimatedTime <= 30) timeMultiplier = 1.0;
            else if (estimatedTime <= 60) timeMultiplier = 1.3;
            else if (estimatedTime <= 120) timeMultiplier = 1.6;
            else timeMultiplier = 1.8; // Cap at 3+ hours
          }
          
          // Difficulty multiplier
          const difficultyMultiplier = DIFFICULTY_MULTIPLIERS[difficulty] || 1.0;
          
          // Calculate foundation XP
          const baseXP = 15; // Minimum meaningful XP
          const foundationXP = Math.round(
            baseXP * 
            cognitiveLevel * 
            subjectWeight * 
            timeMultiplier * 
            difficultyMultiplier
          );
          
          return Math.max(5, foundationXP);
        },

        // Generate insights for user
        generateInsights(patterns, learning, userHistory) {
          const insights = [];
          
          // Category preference insights
          const topCategories = Object.entries(patterns.categoryPreferences)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 3);
          
          if (topCategories.length > 0) {
            insights.push({
              type: 'category_preference',
              title: 'Most Active Categories',
              description: `You focus most on ${topCategories.map(([cat, count]) => `${cat} (${count} tasks)`).join(', ')}`,
              recommendation: 'Consider balancing your learning across different subjects for well-rounded growth.'
            });
          }
          
          // Efficiency insights
          const efficiencyData = Object.entries(patterns.timeEfficiency)
            .filter(([, data]) => data.count >= 3)
            .sort(([,a], [,b]) => a.average - b.average);
          
          if (efficiencyData.length > 0) {
            const mostEfficient = efficiencyData[0];
            const leastEfficient = efficiencyData[efficiencyData.length - 1];
            
            insights.push({
              type: 'efficiency',
              title: 'Time Efficiency Analysis',
              description: `You're most efficient with ${mostEfficient[0]} (${(mostEfficient[1].average * 100).toFixed(0)}% of estimated time) and least efficient with ${leastEfficient[0]} (${(leastEfficient[1].average * 100).toFixed(0)}% of estimated time)`,
              recommendation: `Consider breaking down ${leastEfficient[0]} into smaller tasks or adjusting your time estimates.`
            });
          }
          
          // Learning confidence insights
          if (learning.confidence > 0.7) {
            insights.push({
              type: 'confidence',
              title: 'High Learning Confidence',
              description: `The system has ${Math.round(learning.confidence * 100)}% confidence in predicting your XP needs`,
              recommendation: 'The ML system is well-calibrated to your preferences. Trust the suggestions!'
            });
          } else if (learning.confidence < 0.5) {
            insights.push({
              type: 'confidence',
              title: 'Learning in Progress',
              description: `The system has ${Math.round(learning.confidence * 100)}% confidence in predicting your XP needs`,
              recommendation: 'Continue completing tasks to help the system learn your preferences better.'
            });
          }
          
          return insights;
        }
      };

      const DIFFICULTY_MULTIPLIERS = {
        'Easy': 0.7,
        'Medium': 1.0,
        'Hard': 1.5,
        'Expert': 2.0
      };

      const TIME_MULTIPLIERS = {
        5: 0.5,    // 5 min = 0.5x
        15: 0.8,   // 15 min = 0.8x
        30: 1.0,   // 30 min = 1.0x
        60: 1.3,   // 1 hour = 1.3x
        120: 1.6,  // 2 hours = 1.6x
        240: 2.0   // 4+ hours = 2.0x
      };

      // Passive Focus rates (XP/min) + block bonus per 25 min
      const PASSIVE_RATES = { Training: 0.8, Language: 1.0, Study: 1.2 };
      const PASSIVE_BLOCK_BONUS = 5;

      // Task Templates
      const TASK_TEMPLATES = {
        "CS1010E Practice": {
          category: "CS1010E",
          taskType: "Practice",
          difficulty: "Medium",
          baseXP: 20,
          estimateMin: 30,
          description: "Daily CS1010E practice problems"
        },
        "MA1301 Exercise": {
          category: "MA1301",
          taskType: "Exercise",
          difficulty: "Medium",
          baseXP: 15,
          estimateMin: 25,
          description: "Mathematics exercise practice"
        },
        "Study Session": {
          category: "Study",
          taskType: "Study",
          difficulty: "Medium",
          baseXP: 20,
          estimateMin: 45,
          description: "General study session"
        },
        "Language Practice": {
          category: "Language",
          taskType: "Vocabulary",
          difficulty: "Easy",
          baseXP: 10,
          estimateMin: 15,
          description: "Language learning practice"
        },
        "Workout": {
          category: "Training",
          taskType: "Workout",
          difficulty: "Medium",
          baseXP: 30,
          estimateMin: 60,
          description: "Physical training session"
        }
      };

      // Challenge System
      const CHALLENGES = {
        daily: [
          {
            id: "complete_3_tasks",
            name: "Task Master",
            description: "Complete 3 tasks today",
            target: 3,
            reward: { xp: 50, sp: 0 },
            check: (data) => data.tasksCompletedToday || 0
          },
          {
            id: "focus_25_min",
            name: "Focus Session",
            description: "Complete a 25+ minute focus session",
            target: 1,
            reward: { xp: 30, sp: 0 },
            check: (data) => data.focusSessionsToday || 0
          },
          {
            id: "early_task",
            name: "Early Bird",
            description: "Complete a task before 9 AM",
            target: 1,
            reward: { xp: 25, sp: 0 },
            check: (data) => data.earlyTasksToday || 0
          }
        ],
        weekly: [
          {
            id: "complete_20_tasks",
            name: "Weekly Warrior",
            description: "Complete 20 tasks this week",
            target: 20,
            reward: { xp: 200, sp: 1 },
            check: (data) => data.tasksCompletedThisWeek || 0
          },
          {
            id: "complete_project",
            name: "Project Finisher",
            description: "Complete a project this week",
            target: 1,
            reward: { xp: 150, sp: 0 },
            check: (data) => data.projectsCompletedThisWeek || 0
          },
          {
            id: "spend_sp",
            name: "Skill Investor",
            description: "Spend 3 skill points this week",
            target: 3,
            reward: { xp: 100, sp: 1 },
            check: (data) => data.spSpentThisWeek || 0
          }
        ]
      };

      // Title System
      const TITLE_SYSTEM = {
        level: [
          { level: 0, title: "Novice" },
          { level: 10, title: "Apprentice" },
          { level: 25, title: "Adept" },
          { level: 50, title: "Expert" },
          { level: 75, title: "Master" },
          { level: 100, title: "Grandmaster" },
          { level: 150, title: "Legend" },
          { level: 200, title: "Mythic" }
        ],
        achievement: {
          streak: [
            {
              title: "Streak Master",
              condition: (data) => data.maxStreak >= 30
            },
            {
              title: "Consistency King",
              condition: (data) => data.maxStreak >= 7
            }
          ],
          focus: [
            {
              title: "Zen Master",
              condition: (data) => data.totalFocusHours >= 100
            },
            {
              title: "Focused",
              condition: (data) => data.totalFocusHours >= 10
            }
          ]
        },
        special: [
          {
            title: "XP Master",
            condition: (data) => data.maxDailyXP >= 10000
          },
          {
            title: "Efficiency Expert",
            condition: (data) => data.efficientTasks >= 100
          },
          {
            title: "Dedicated",
            condition: (data) => data.consecutiveDays >= 100
          }
        ]
      };

      // Smart Scheduling System
      const SMART_SCHEDULING = {
        analyzePatterns(log) {
          const hourlyStats = {};
          log.filter(e => e.type === "task").forEach(entry => {
            const hour = new Date(entry.ts).getHours();
            if (!hourlyStats[hour]) {
              hourlyStats[hour] = { count: 0, totalXP: 0 };
            }
            hourlyStats[hour].count++;
            hourlyStats[hour].totalXP += entry.amount || 0;
          });
          return hourlyStats;
        },

        suggestOptimalTime(category, taskType, difficulty, hourlyStats) {
          // Simple heuristic based on common productivity patterns
          const currentHour = new Date().getHours();
          let recommendedTime = "9:00 AM - 11:00 AM";
          let reasoning = "Morning hours typically show high productivity";
          let confidence = 75;

          if (category === "Training") {
            recommendedTime = "6:00 AM - 8:00 AM or 6:00 PM - 8:00 PM";
            reasoning = "Training sessions work best early morning or evening";
            confidence = 85;
          } else if (category === "Study" || category === "CS1010E" || category === "MA1301") {
            recommendedTime = "9:00 AM - 12:00 PM";
            reasoning = "Academic work is most effective in morning hours";
            confidence = 80;
          } else if (difficulty === "Hard" || difficulty === "Expert") {
            recommendedTime = "10:00 AM - 12:00 PM";
            reasoning = "Complex tasks require peak mental energy";
            confidence = 85;
          }

          return { recommendedTime, reasoning, confidence };
        },

        getEnergyLevel() {
          const hour = new Date().getHours();
          let level = 0.5;
          let description = "Moderate";

          if (hour >= 6 && hour <= 10) {
            level = 0.9;
            description = "Peak Energy";
          } else if (hour >= 11 && hour <= 14) {
            level = 0.8;
            description = "High Energy";
          } else if (hour >= 15 && hour <= 17) {
            level = 0.6;
            description = "Moderate Energy";
          } else if (hour >= 18 && hour <= 20) {
            level = 0.7;
            description = "Good Energy";
          } else {
            level = 0.4;
            description = "Low Energy";
          }

          return { level, description };
        }
      };

      // ================== COMPREHENSIVE SKILL TREE SYSTEM ==================
      
      // Subject definitions with icons and colors
      const SUBJECTS = {
        math: { id: 'math', name: 'Math', icon: '📚', color: 'blue', baseXP: 0 },
        programming: { id: 'programming', name: 'Programming', icon: '💻', color: 'green', baseXP: 0 },
        economics: { id: 'economics', name: 'Economics', icon: '📊', color: 'purple', baseXP: 0 },
        history: { id: 'history', name: 'History', icon: '📜', color: 'amber', baseXP: 0 }
      };

      // Complete skill tree structures
      const SKILL_TREES = {
        math: {
          id: 'math',
          name: 'Mathematics',
          icon: '📚',
          mainSkills: {
            'pre_calculus': {
              id: 'pre_calculus',
              name: 'Pre-Calculus',
              xpRequired: 0,
              unlockRequirements: { tasksCompleted: 0 },
              subSkills: {
                'arithmetic_foundations': {
                  id: 'arithmetic_foundations',
                  name: 'Arithmetic Foundations',
                  xpRequired: 0,
                  unlockRequirements: { tasksCompleted: 0 },
                  baseXP: 10,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                },
                'algebra_i': {
                  id: 'algebra_i',
                  name: 'Algebra I',
                  xpRequired: 100,
                  unlockRequirements: { tasksCompleted: 5, prerequisites: ['arithmetic_foundations'] },
                  baseXP: 15,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                },
                'algebra_ii': {
                  id: 'algebra_ii',
                  name: 'Algebra II',
                  xpRequired: 300,
                  unlockRequirements: { tasksCompleted: 10, prerequisites: ['algebra_i'] },
                  baseXP: 20,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                },
                'trigonometry': {
                  id: 'trigonometry',
                  name: 'Trigonometry',
                  xpRequired: 500,
                  unlockRequirements: { tasksCompleted: 15, prerequisites: ['algebra_ii'] },
                  baseXP: 25,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                }
              }
            },
            'calculus_sequence': {
              id: 'calculus_sequence',
              name: 'Calculus Sequence',
              xpRequired: 800,
              unlockRequirements: { tasksCompleted: 20, prerequisites: ['pre_calculus'] },
              subSkills: {
                'limits_continuity': {
                  id: 'limits_continuity',
                  name: 'Limits & Continuity',
                  xpRequired: 0,
                  unlockRequirements: { tasksCompleted: 0 },
                  baseXP: 30,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                },
                'differential_calculus': {
                  id: 'differential_calculus',
                  name: 'Differential Calculus',
                  xpRequired: 200,
                  unlockRequirements: { tasksCompleted: 8, prerequisites: ['limits_continuity'] },
                  baseXP: 35,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                },
                'integral_calculus': {
                  id: 'integral_calculus',
                  name: 'Integral Calculus',
                  xpRequired: 400,
                  unlockRequirements: { tasksCompleted: 12, prerequisites: ['differential_calculus'] },
                  baseXP: 40,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                }
              }
            },
            'linear_algebra': {
              id: 'linear_algebra',
              name: 'Linear Algebra',
              xpRequired: 600,
              unlockRequirements: { tasksCompleted: 25, prerequisites: ['pre_calculus'] },
              subSkills: {
                'vectors_matrices': {
                  id: 'vectors_matrices',
                  name: 'Vectors & Matrices',
                  xpRequired: 0,
                  unlockRequirements: { tasksCompleted: 0 },
                  baseXP: 25,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                },
                'eigenvalues_eigenvectors': {
                  id: 'eigenvalues_eigenvectors',
                  name: 'Eigenvalues & Eigenvectors',
                  xpRequired: 300,
                  unlockRequirements: { tasksCompleted: 10, prerequisites: ['vectors_matrices'] },
                  baseXP: 35,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                }
              }
            }
          }
        },
        
        programming: {
          id: 'programming',
          name: 'Programming & Computer Science',
          icon: '💻',
          mainSkills: {
            'foundations': {
              id: 'foundations',
              name: 'Foundations',
              xpRequired: 0,
              unlockRequirements: { tasksCompleted: 0 },
              subSkills: {
                'computer_literacy': {
                  id: 'computer_literacy',
                  name: 'Computer Literacy',
                  xpRequired: 0,
                  unlockRequirements: { tasksCompleted: 0 },
                  baseXP: 10,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                },
                'programming_fundamentals': {
                  id: 'programming_fundamentals',
                  name: 'Programming Fundamentals',
                  xpRequired: 50,
                  unlockRequirements: { tasksCompleted: 3, prerequisites: ['computer_literacy'] },
                  baseXP: 15,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                },
                'data_structures': {
                  id: 'data_structures',
                  name: 'Data Structures',
                  xpRequired: 200,
                  unlockRequirements: { tasksCompleted: 8, prerequisites: ['programming_fundamentals'] },
                  baseXP: 25,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                },
                'algorithms': {
                  id: 'algorithms',
                  name: 'Algorithms',
                  xpRequired: 300,
                  unlockRequirements: { tasksCompleted: 12, prerequisites: ['data_structures'] },
                  baseXP: 30,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                }
              }
            },
            'software_engineering': {
              id: 'software_engineering',
              name: 'Software Engineering',
              xpRequired: 400,
              unlockRequirements: { tasksCompleted: 15, prerequisites: ['foundations'] },
              subSkills: {
                'version_control': {
                  id: 'version_control',
                  name: 'Version Control',
                  xpRequired: 0,
                  unlockRequirements: { tasksCompleted: 0 },
                  baseXP: 20,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                },
                'testing_debugging': {
                  id: 'testing_debugging',
                  name: 'Testing & Debugging',
                  xpRequired: 100,
                  unlockRequirements: { tasksCompleted: 5, prerequisites: ['version_control'] },
                  baseXP: 25,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                },
                'databases': {
                  id: 'databases',
                  name: 'Databases',
                  xpRequired: 200,
                  unlockRequirements: { tasksCompleted: 8, prerequisites: ['testing_debugging'] },
                  baseXP: 30,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                }
              }
            }
          }
        },

        economics: {
          id: 'economics',
          name: 'Economics',
          icon: '📊',
          mainSkills: {
            'microeconomics': {
              id: 'microeconomics',
              name: 'Microeconomics',
              xpRequired: 0,
              unlockRequirements: { tasksCompleted: 0 },
              subSkills: {
                'supply_demand': {
                  id: 'supply_demand',
                  name: 'Supply & Demand',
                  xpRequired: 0,
                  unlockRequirements: { tasksCompleted: 0 },
                  baseXP: 15,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                },
                'consumer_theory': {
                  id: 'consumer_theory',
                  name: 'Consumer Theory',
                  xpRequired: 100,
                  unlockRequirements: { tasksCompleted: 5, prerequisites: ['supply_demand'] },
                  baseXP: 20,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                },
                'producer_theory': {
                  id: 'producer_theory',
                  name: 'Producer Theory',
                  xpRequired: 200,
                  unlockRequirements: { tasksCompleted: 8, prerequisites: ['consumer_theory'] },
                  baseXP: 25,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                }
              }
            },
            'macroeconomics': {
              id: 'macroeconomics',
              name: 'Macroeconomics',
              xpRequired: 300,
              unlockRequirements: { tasksCompleted: 12, prerequisites: ['microeconomics'] },
              subSkills: {
                'gdp_measurement': {
                  id: 'gdp_measurement',
                  name: 'GDP & Measurement',
                  xpRequired: 0,
                  unlockRequirements: { tasksCompleted: 0 },
                  baseXP: 20,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                },
                'fiscal_policy': {
                  id: 'fiscal_policy',
                  name: 'Fiscal Policy',
                  xpRequired: 150,
                  unlockRequirements: { tasksCompleted: 6, prerequisites: ['gdp_measurement'] },
                  baseXP: 25,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                }
              }
            }
          }
        },

        history: {
          id: 'history',
          name: 'History',
          icon: '📜',
          mainSkills: {
            'historical_methods': {
              id: 'historical_methods',
              name: 'Historical Methods',
              xpRequired: 0,
              unlockRequirements: { tasksCompleted: 0 },
              subSkills: {
                'sourcing_corroboration': {
                  id: 'sourcing_corroboration',
                  name: 'Sourcing & Corroboration',
                  xpRequired: 0,
                  unlockRequirements: { tasksCompleted: 0 },
                  baseXP: 15,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                },
                'historiography': {
                  id: 'historiography',
                  name: 'Historiography',
                  xpRequired: 100,
                  unlockRequirements: { tasksCompleted: 5, prerequisites: ['sourcing_corroboration'] },
                  baseXP: 20,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                }
              }
            },
            'ancient_history': {
              id: 'ancient_history',
              name: 'Ancient History',
              xpRequired: 200,
              unlockRequirements: { tasksCompleted: 8, prerequisites: ['historical_methods'] },
              subSkills: {
                'mesopotamia': {
                  id: 'mesopotamia',
                  name: 'Mesopotamia',
                  xpRequired: 0,
                  unlockRequirements: { tasksCompleted: 0 },
                  baseXP: 18,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                },
                'ancient_greece': {
                  id: 'ancient_greece',
                  name: 'Ancient Greece',
                  xpRequired: 150,
                  unlockRequirements: { tasksCompleted: 6, prerequisites: ['mesopotamia'] },
                  baseXP: 22,
                  masteryLevels: ['Novice', 'Apprentice', 'Proficient', 'Advanced', 'Expert']
                }
              }
            }
          }
        }
      };

      // Dual XP System
      const XP_SYSTEM = {
        // Calculate subject level from XP
        getSubjectLevel: (xp) => {
          if (xp < 100) return 0;
          if (xp < 300) return 1;
          if (xp < 600) return 2;
          if (xp < 1000) return 3;
          if (xp < 1500) return 4;
          if (xp < 2100) return 5;
          if (xp < 2800) return 6;
          if (xp < 3600) return 7;
          if (xp < 4500) return 8;
          if (xp < 5500) return 9;
          return 10; // Max level for now
        },

        // Calculate mastery level from XP within a sub-skill
        getMasteryLevel: (xp, maxXP = 1000) => {
          const percentage = Math.min(xp / maxXP, 1);
          if (percentage < 0.2) return 0; // Novice
          if (percentage < 0.4) return 1; // Apprentice
          if (percentage < 0.6) return 2; // Proficient
          if (percentage < 0.8) return 3; // Advanced
          return 4; // Expert
        },

        // Check if a skill is unlocked
        isSkillUnlocked: (skill, userProgress) => {
          const requirements = skill.unlockRequirements;
          if (!requirements) return true;

          // Check task completion requirements
          if (requirements.tasksCompleted) {
            const completedTasks = userProgress.tasksCompleted || 0;
            if (completedTasks < requirements.tasksCompleted) return false;
          }

          // Check prerequisite skills
          if (requirements.prerequisites) {
            for (const prereqId of requirements.prerequisites) {
              const prereqXP = userProgress.subSkills?.[prereqId]?.xp || 0;
              if (prereqXP < 100) return false; // Minimum XP threshold
            }
          }

          return true;
        }
      };

      // Time-based XP calculation with efficiency bonuses
      const calculateTaskXP = (subSkill, baseXP, estimatedTime, actualTime, difficulty = 'Medium') => {
        // Base XP calculation
        let finalXP = baseXP;

        // Apply difficulty multiplier
        const difficultyMultipliers = { 'Easy': 0.7, 'Medium': 1.0, 'Hard': 1.5, 'Expert': 2.0 };
        finalXP *= difficultyMultipliers[difficulty] || 1.0;

        // Apply time efficiency bonus
        if (actualTime && estimatedTime && actualTime > 0) {
          const efficiency = actualTime / estimatedTime;
          const timeBonus = Math.max(0, (1 - efficiency) * 0.5); // Up to 50% bonus for finishing early
          finalXP *= (1 + timeBonus);
        }

        // Apply sub-skill level bonus (higher level = more XP)
        const subSkillLevel = XP_SYSTEM.getSubjectLevel(subSkill.xp || 0);
        const levelBonus = 1 + (subSkillLevel * 0.05); // 5% per level
        finalXP *= levelBonus;

        return Math.round(finalXP);
      };

      // ================== Storage Hook ==================
      function useLocalStorage(key, initialValue) {
        const [value, setValue] = useState(() => {
          try { const raw = localStorage.getItem(key); return raw ? JSON.parse(raw) : initialValue; } catch { return initialValue; }
        });
        useEffect(()=>{ localStorage.setItem(key, JSON.stringify(value)); }, [key, value]);
        return [value, setValue];
      }

      // ================== Cloud Backup System ==================
      class CloudBackup {
        constructor() {
          this.auth = window.firebaseAuth;
          this.db = window.firebaseDb;
          this.authMethods = window.firebaseAuthMethods;
          this.dbMethods = window.firebaseDbMethods;
          this.isOnline = navigator.onLine;
          this.syncQueue = [];
          this.lastSyncTime = null;
          this.user = null;
          
          // Listen for online/offline status
          window.addEventListener('online', () => {
            this.isOnline = true;
            this.processSyncQueue();
          });
          
          window.addEventListener('offline', () => {
            this.isOnline = false;
          });
        }

        async getUserData() {
          if (!this.user) return null;
          
          try {
            const userRef = this.dbMethods.doc(this.db, 'users', this.user.uid);
            const userDoc = await this.dbMethods.getDoc(userRef);
            
            if (userDoc.exists()) {
              const data = userDoc.data();
              this.lastSyncTime = data.lastSync?.toDate() || null;
              return data;
            }
            return null;
          } catch (error) {
            console.error('Error fetching user data:', error);
            return null;
          }
        }

        async saveUserData(userData) {
          if (!this.user) return false;
          
          try {
            const userRef = this.dbMethods.doc(this.db, 'users', this.user.uid);
            await this.dbMethods.setDoc(userRef, {
              ...userData,
              lastSync: this.dbMethods.serverTimestamp(),
              userId: this.user.uid
            }, { merge: true });
            
            this.lastSyncTime = new Date();
            return true;
          } catch (error) {
            console.error('Error saving user data:', error);
            return false;
          }
        }

        mergeData(localData, cloudData) {
          const merged = { ...cloudData };
          
          ['tasks', 'projects', 'log'].forEach(key => {
            const local = localData[key] || [];
            const cloud = cloudData[key] || [];
            
            const localMap = new Map(local.map(item => [item.id, item]));
            const cloudMap = new Map(cloud.map(item => [item.id, item]));
            
            const mergedArray = [...cloud];
            local.forEach(item => {
              if (cloudMap.has(item.id)) {
                const index = mergedArray.findIndex(existing => existing.id === item.id);
                mergedArray[index] = item;
              } else {
                mergedArray.push(item);
              }
            });
            
            merged[key] = mergedArray;
          });
          
          ['xp', 'skill', 'lastLevel', 'milestones', 'dateInfo', 'settings', 'theme', 'subjectXP', 'subSkillProgress', 'activeTab'].forEach(key => {
            if (localData[key] !== undefined) {
              merged[key] = localData[key];
            }
          });
          
          return merged;
        }

        async syncData(localData) {
          if (!this.user || !this.isOnline) {
            this.addToSyncQueue(localData);
            return localData;
          }

          try {
            const cloudData = await this.getUserData();
            
            if (!cloudData) {
              await this.saveUserData(localData);
              return localData;
            }

            const mergedData = this.mergeData(localData, cloudData);
            await this.saveUserData(mergedData);
            return mergedData;
            
          } catch (error) {
            console.error('Sync error:', error);
            this.addToSyncQueue(localData);
            return localData;
          }
        }

        addToSyncQueue(data) {
          this.syncQueue.push({ data, timestamp: Date.now() });
          if (this.syncQueue.length > 5) {
            this.syncQueue = this.syncQueue.slice(-5);
          }
        }

        async processSyncQueue() {
          if (!this.isOnline || this.syncQueue.length === 0) return;
          
          const latestSync = this.syncQueue[this.syncQueue.length - 1];
          try {
            await this.syncData(latestSync.data);
            this.syncQueue = [];
          } catch (error) {
            console.error('Failed to process sync queue:', error);
          }
        }

        isAuthenticated() {
          return !!this.user;
        }

        getSyncStatus() {
          return {
            isOnline: this.isOnline,
            isAuthenticated: this.isAuthenticated(),
            lastSync: this.lastSyncTime,
            queuedSyncs: this.syncQueue.length
          };
        }
      }

      // ================== Tab Components ==================
      
      function SkillsTab({ activeSubject, setActiveSubject, subjectXP, subSkillProgress, setForm, log, setActiveTab }) {
        const [expandedSubjects, setExpandedSubjects] = useState({});
        const [expandedMainSkills, setExpandedMainSkills] = useState({});
        
        const toggleSubject = (subject) => {
          setExpandedSubjects(prev => ({
            ...prev,
            [subject]: !prev[subject]
          }));
        };
        
        const toggleMainSkill = (mainSkillId) => {
          setExpandedMainSkills(prev => ({
            ...prev,
            [mainSkillId]: !prev[mainSkillId]
          }));
        };
        
        return (
          <div className="space-y-6">
            {/* Hierarchical Skill Tree */}
            <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5">
              <h2 className="text-xl font-semibold mb-4">Skill Tree</h2>
              <div className="text-sm text-neutral-400 mb-6">
                Click on subjects and skills to expand/collapse. Click on sub-skills to create tasks.
              </div>

              {/* Hierarchical Tree Structure */}
              <div className="space-y-4">
                {Object.entries(SUBJECTS).map(([subjectId, subject]) => {
                  const isExpanded = expandedSubjects[subjectId];
                  const subjectLevel = XP_SYSTEM.getSubjectLevel(subjectXP[subjectId] || 0);
                  
                  return (
                    <div key={subjectId} className="border border-neutral-700 rounded-xl overflow-hidden">
                      {/* Subject Header */}
                      <div 
                        className="p-4 bg-neutral-800 hover:bg-neutral-750 cursor-pointer transition-all"
                        onClick={() => toggleSubject(subjectId)}
                      >
                        <div className="flex items-center justify-between">
                          <div className="flex items-center gap-3">
                            <span className="text-xl">{subject.icon}</span>
                            <div>
                              <div className="font-semibold text-lg">{subject.name}</div>
                              <div className="text-sm text-neutral-400">
                                Level {subjectLevel} • {subjectXP[subjectId] || 0} XP
                              </div>
                            </div>
                          </div>
                          <div className="flex items-center gap-3">
                            {/* Progress Bar */}
                            <div className="w-32 bg-neutral-700 rounded-full h-2">
                              <div 
                                className="bg-blue-500 h-2 rounded-full transition-all duration-300" 
                                style={{ width: `${Math.min(100, ((subjectXP[subjectId] || 0) / 10000) * 100)}%` }}
                              />
                            </div>
                            <div className={`transform transition-transform ${isExpanded ? 'rotate-90' : ''}`}>
                              <svg className="w-5 h-5 text-neutral-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                              </svg>
                            </div>
                          </div>
                        </div>
                      </div>
                      
                      {/* Main Skills */}
                      {isExpanded && SKILL_TREES[subjectId] && (
                        <div className="bg-neutral-900 p-4 border-t border-neutral-700">
                          <div className="space-y-3">
                            {Object.entries(SKILL_TREES[subjectId].mainSkills).map(([mainSkillId, mainSkill]) => {
                              const isMainExpanded = expandedMainSkills[mainSkillId];
                              const mainSkillXP = Object.keys(mainSkill.subSkills).reduce((total, subSkillId) => {
                                return total + (subSkillProgress[subSkillId]?.xp || 0);
                              }, 0);
                              const isMainSkillUnlocked = XP_SYSTEM.isSkillUnlocked(mainSkill, { 
                                tasksCompleted: log.filter(e => e.type === "task").length 
                              });
                              
                              return (
                                <div key={mainSkillId} className="border border-neutral-600 rounded-lg overflow-hidden">
                                  {/* Main Skill Header */}
                                  <div 
                                    className="p-3 bg-neutral-800 hover:bg-neutral-750 cursor-pointer transition-all"
                                    onClick={() => toggleMainSkill(mainSkillId)}
                                  >
                                    <div className="flex items-center justify-between">
                                      <div className="flex items-center gap-2">
                                        <div className="font-semibold">{mainSkill.name}</div>
                                        <div className={`px-2 py-1 rounded-full text-xs ${
                                          isMainSkillUnlocked 
                                            ? 'bg-green-900/50 text-green-200 border border-green-800'
                                            : 'bg-neutral-700 text-neutral-400 border border-neutral-600'
                                        }`}>
                                          {isMainSkillUnlocked ? 'Unlocked' : 'Locked'}
                                        </div>
                                      </div>
                                      <div className="flex items-center gap-2">
                                        <div className="text-sm text-neutral-400">{mainSkillXP} XP</div>
                                        <div className={`transform transition-transform ${isMainExpanded ? 'rotate-90' : ''}`}>
                                          <svg className="w-4 h-4 text-neutral-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                                          </svg>
                                        </div>
                                      </div>
                                    </div>
                                  </div>
                                  
                                  {/* Sub-Skills */}
                                  {isMainExpanded && (
                                    <div className="bg-neutral-900 p-3 border-t border-neutral-600">
                                      <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                                        {Object.entries(mainSkill.subSkills).map(([subSkillId, subSkill]) => {
                                          const progress = subSkillProgress[subSkillId] || { xp: 0, tasksCompleted: 0 };
                                          const isUnlocked = XP_SYSTEM.isSkillUnlocked(subSkill, progress);
                                          const masteryLevel = XP_SYSTEM.getMasteryLevel(progress.xp);
                                          const masteryName = subSkill.masteryLevels[masteryLevel];
                                          const progressPercent = Math.min(100, (progress.xp / 1000) * 100);
                                          
                                          return (
                                            <div
                                              key={subSkillId}
                                              className={`p-3 rounded-lg border transition-all cursor-pointer ${
                                                isUnlocked
                                                  ? 'bg-neutral-700 border-neutral-600 hover:border-neutral-500 hover:bg-neutral-650'
                                                  : 'bg-neutral-800 border-neutral-700 opacity-60'
                                              }`}
                                              onClick={() => {
                                                if (isUnlocked) {
                                                  setForm(prev => ({
                                                    ...prev,
                                                    subject: subjectId,
                                                    mainSkill: mainSkillId,
                                                    subSkill: subSkillId
                                                  }));
                                                  setActiveTab('tasks');
                                                }
                                              }}
                                            >
                                              <div className="flex items-center justify-between mb-2">
                                                <div className="font-semibold text-sm">{subSkill.name}</div>
                                                <div className="text-xs text-neutral-400">{progress.xp} XP</div>
                                              </div>
                                              
                                              <div className="text-xs text-neutral-500 mb-2">
                                                {masteryName} • {progress.tasksCompleted} tasks
                                              </div>
                                              
                                              <div className="w-full bg-neutral-800 rounded-full h-2 mb-2">
                                                <div 
                                                  className="bg-blue-500 h-2 rounded-full transition-all duration-300" 
                                                  style={{ width: `${progressPercent}%` }}
                                                />
                                              </div>
                                              
                                              {!isUnlocked && (
                                                <div className="text-xs text-amber-400">
                                                  Requires: {subSkill.unlockRequirements.tasksCompleted || 0} tasks
                                                </div>
                                              )}
                                            </div>
                                          );
                                        })}
                                      </div>
                                    </div>
                                  )}
                                </div>
                              );
                            })}
                          </div>
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
          </div>
        );
      }

      function TasksTab({ form, setForm, addTask, tasks, completeTask, deleteTask, xpLearning, getMLRecommendation, calculateAutoXP }) {
        return (
          <div className="space-y-6">
            {/* Add Task Form */}
            <form onSubmit={addTask} className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5">
              <h2 className="text-xl font-semibold mb-4">Add New Task</h2>
              
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3 mb-4">
                <input 
                  className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                  placeholder="Task title"
                  value={form.title} 
                  onChange={e=> setForm({...form, title:e.target.value})} 
                />
                
                <select 
                  className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                  value={form.subject} 
                  onChange={e=> {
                    const newSubject = e.target.value;
                    const subjectTree = SKILL_TREES[newSubject];
                    const firstMainSkill = Object.keys(subjectTree.mainSkills)[0];
                    const firstSubSkill = Object.keys(subjectTree.mainSkills[firstMainSkill].subSkills)[0];
                    setForm({
                      ...form, 
                      subject: newSubject,
                      mainSkill: firstMainSkill,
                      subSkill: firstSubSkill
                    });
                  }}
                >
                  {Object.entries(SUBJECTS).map(([id, subject]) => (
                    <option key={id} value={id}>{subject.icon} {subject.name}</option>
                  ))}
                </select>
                
                <select 
                  className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                  value={form.mainSkill} 
                  onChange={e=> {
                    const newMainSkill = e.target.value;
                    const firstSubSkill = Object.keys(SKILL_TREES[form.subject].mainSkills[newMainSkill].subSkills)[0];
                    setForm({...form, mainSkill: newMainSkill, subSkill: firstSubSkill});
                  }}
                >
                  {form.subject && Object.entries(SKILL_TREES[form.subject].mainSkills).map(([id, skill]) => (
                    <option key={id} value={id}>{skill.name}</option>
                  ))}
                </select>
                
                <select 
                  className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                  value={form.subSkill} 
                  onChange={e=> setForm({...form, subSkill:e.target.value})}
                >
                  {form.subject && form.mainSkill && Object.entries(SKILL_TREES[form.subject].mainSkills[form.mainSkill].subSkills).map(([id, skill]) => (
                    <option key={id} value={id}>{skill.name}</option>
                  ))}
                </select>
              </div>
              
              <div className="grid grid-cols-1 md:grid-cols-3 gap-3 mb-4">
                <select 
                  className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                  value={form.difficulty} 
                  onChange={e=> setForm({...form, difficulty:e.target.value})}
                >
                  <option value="Easy">Easy</option>
                  <option value="Medium">Medium</option>
                  <option value="Hard">Hard</option>
                  <option value="Expert">Expert</option>
                </select>
                
                <input 
                  type="number" 
                  min="0" 
                  className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                  placeholder="Estimate (min)" 
                  value={form.estimateMin} 
                  onChange={e=> setForm({...form, estimateMin:e.target.value})} 
                />
                
                <div className="flex items-center gap-2">
                  <input 
                    type="number" 
                    min="1" 
                    className="flex-1 bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                    placeholder="Base XP" 
                    value={form.baseXP} 
                    onChange={e=> setForm({...form, baseXP:e.target.value})} 
                  />
                  <span className="text-xs text-neutral-400">
                    Suggested: {form.suggestedXP}
                  </span>
                </div>
              </div>
              
              {/* Enhanced XP Recommendations */}
              <div className="mb-4 space-y-3">
                {/* Auto XP Option */}
                <div className="p-3 bg-emerald-950/20 border border-emerald-800 rounded-xl">
                  <div className="flex items-center justify-between mb-2">
                    <div className="text-sm font-semibold text-emerald-300">Auto XP (Recommended)</div>
                    <div className="text-xs text-emerald-400">
                      {(() => {
                        const autoXP = calculateAutoXP(form.subject, form.subSkill, 'Practice', form.difficulty, form.estimateMin);
                        return autoXP.source || 'Academic Knowledge';
                      })()}
                    </div>
                  </div>
                  <div className="flex items-center gap-2">
                    <button 
                      type="button"
                      onClick={()=> {
                        const autoXP = calculateAutoXP(form.subject, form.subSkill, 'Practice', form.difficulty, form.estimateMin);
                        setForm({...form, baseXP: autoXP.xp});
                      }}
                      className="bg-emerald-600 hover:bg-emerald-500 text-white rounded-xl px-3 py-2 text-sm font-semibold shadow"
                    >
                      {(() => {
                        const autoXP = calculateAutoXP(form.subject, form.subSkill, 'Practice', form.difficulty, form.estimateMin);
                        return `Use Auto XP (${autoXP.xp} XP)`;
                      })()}
                    </button>
                    <div className="text-xs text-neutral-400">
                      {(() => {
                        const autoXP = calculateAutoXP(form.subject, form.subSkill, 'Practice', form.difficulty, form.estimateMin);
                        const objective = autoXP.breakdown?.objective || autoXP.xp;
                        return `Objective: ${objective} XP`;
                      })()}
                    </div>
                  </div>
                </div>

                {/* ML Recommendations (if available) */}
                {Object.keys(xpLearning.userAdjustments).length > 3 && (
                  <div className="p-3 bg-purple-950/20 border border-purple-800 rounded-xl">
                    <div className="flex items-center justify-between mb-2">
                      <div className="text-sm font-semibold text-purple-300">ML Recommendation</div>
                      <div className="text-xs text-purple-400">
                        {(() => {
                          const mlRec = getMLRecommendation(form.subject, form.subSkill, 'Practice', form.difficulty, form.estimateMin);
                          return `Confidence: ${mlRec.confidence}%`;
                        })()}
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      <button 
                        type="button"
                        onClick={()=> {
                          const mlRec = getMLRecommendation(form.subject, form.subSkill, 'Practice', form.difficulty, form.estimateMin);
                          setForm({...form, baseXP: mlRec.xp});
                        }}
                        className="bg-purple-600 hover:bg-purple-500 text-white rounded-xl px-3 py-2 text-sm font-semibold shadow"
                      >
                        {(() => {
                          const mlRec = getMLRecommendation(form.subject, form.subSkill, 'Practice', form.difficulty, form.estimateMin);
                          return `Use ML (${mlRec.xp} XP)`;
                        })()}
                      </button>
                      <div className="text-xs text-neutral-400">
                        {(() => {
                          const mlRec = getMLRecommendation(form.subject, form.subSkill, 'Practice', form.difficulty, form.estimateMin);
                          return `Objective: ${mlRec.objective} XP`;
                        })()}
                      </div>
                    </div>
                  </div>
                )}
              </div>
              
              <div className="grid grid-cols-1 md:grid-cols-1 gap-3 mb-4">
              </div>
              
              <button className="w-full bg-emerald-600 hover:bg-emerald-500 text-white rounded-xl px-4 py-2 font-semibold shadow">
                Add Task
              </button>
            </form>

            {/* Tasks List */}
            <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 divide-y divide-neutral-800 overflow-hidden">
              {tasks.length===0 ? (
                <div className="p-6 text-neutral-400">No tasks yet. Add your first task above.</div>
              ) : (
                tasks.map(t=>{
                  const completed = (t.timesCompletedToday||0) > 0;
                  const streakText = t.streak ? `${t.streak}🔥` : "—";
                  return (
                    <div key={t.id} className="p-4 flex items-center gap-4">
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center gap-2 flex-wrap">
                          <div className="text-base font-semibold truncate">{t.title}</div>
                          <span className="text-xs px-2 py-0.5 rounded-full bg-blue-900/40 text-blue-200 border border-blue-800">
                            {SUBJECTS[t.subject]?.icon} {SUBJECTS[t.subject]?.name}
                          </span>
                          <span className="text-xs px-2 py-0.5 rounded-full bg-neutral-800 text-neutral-300 border border-neutral-700">
                            {t.subSkillName}
                          </span>
                          {t.difficulty && (
                            <span className={`text-xs px-2 py-0.5 rounded-full border ${
                              t.difficulty === 'Easy' ? 'bg-green-900/40 text-green-200 border-green-800' :
                              t.difficulty === 'Medium' ? 'bg-yellow-900/40 text-yellow-200 border-yellow-800' :
                              t.difficulty === 'Hard' ? 'bg-orange-900/40 text-orange-200 border-orange-800' :
                              'bg-red-900/40 text-red-200 border-red-800'
                            }`}>
                              {t.difficulty}
                            </span>
                          )}
                        </div>
                        <div className="text-xs text-neutral-400 mt-1">
                          Base {t.baseXP} XP • Est {t.estimateMin||0} min • Streak {streakText} • Last: {t.lastCompleted || "—"}
                        </div>
                      </div>
                      <div className="flex items-center gap-2">
                        <button onClick={()=> completeTask(t.id)} disabled={completed}
                          className={`px-3 py-2 rounded-xl text-sm font-semibold shadow
                            ${completed ? "bg-neutral-800 text-neutral-500 cursor-not-allowed" : "bg-emerald-600 hover:bg-emerald-500 text-white"}`}>
                          {completed ? "Done Today" : "Complete (+XP)"}
                        </button>
                        <button onClick={()=> deleteTask(t.id)}
                          className="px-3 py-2 rounded-xl text-sm font-semibold bg-rose-900/60 hover:bg-rose-800 text-rose-100 shadow">
                          Delete
                        </button>
                      </div>
                    </div>
                  );
                })
              )}
            </div>
          </div>
        );
      }

      // PoE-Style Skill Tree Component - REMOVED (replaced with hierarchical view)
      function PoEStyleSkillTree_OLD({ activeSubject, subjectXP, subSkillProgress, setForm, log, setActiveTab }) {
        const [zoom, setZoom] = useState(1);
        const [panX, setPanX] = useState(0);
        const [panY, setPanY] = useState(0);
        const [dragging, setDragging] = useState(false);
        const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
        const [hoveredNode, setHoveredNode] = useState(null);

        // Sample PoE-style skill tree data (simplified version)
        const poeSkillTree = {
          math: {
            nodes: {
              math_start: {
                id: 'math_start',
                name: 'Mathematical Foundations',
                type: 'keystone',
                x: 0,
                y: 0,
                description: 'The foundation of all mathematical knowledge',
                requirements: { tasksCompleted: 0 },
                connections: ['math_arithmetic', 'math_algebra_branch']
              },
              math_arithmetic: {
                id: 'math_arithmetic',
                name: 'Arithmetic',
                type: 'small',
                x: -100,
                y: -50,
                description: 'Basic number operations and properties',
                requirements: { tasksCompleted: 1 },
                connections: ['math_fractions', 'math_decimals']
              },
              math_fractions: {
                id: 'math_fractions',
                name: 'Fractions',
                type: 'small',
                x: -150,
                y: -100,
                description: 'Working with fractional numbers',
                requirements: { tasksCompleted: 2 },
                connections: []
              },
              math_decimals: {
                id: 'math_decimals',
                name: 'Decimals',
                type: 'small',
                x: -150,
                y: 0,
                description: 'Decimal number operations',
                requirements: { tasksCompleted: 2 },
                connections: []
              },
              math_algebra_branch: {
                id: 'math_algebra_branch',
                name: 'Algebra Pathway',
                type: 'notable',
                x: 100,
                y: 0,
                description: 'Unlocks the algebra skill tree',
                requirements: { tasksCompleted: 3 },
                connections: ['math_algebra1', 'math_variables']
              },
              math_variables: {
                id: 'math_variables',
                name: 'Variables',
                type: 'small',
                x: 150,
                y: -50,
                description: 'Understanding variables and expressions',
                requirements: { tasksCompleted: 4 },
                connections: ['math_equations']
              },
              math_equations: {
                id: 'math_equations',
                name: 'Linear Equations',
                type: 'small',
                x: 200,
                y: -100,
                description: 'Solving linear equations',
                requirements: { tasksCompleted: 5 },
                connections: []
              },
              math_algebra1: {
                id: 'math_algebra1',
                name: 'Algebra I',
                type: 'notable',
                x: 150,
                y: 50,
                description: 'Fundamental algebraic concepts',
                requirements: { tasksCompleted: 6 },
                connections: ['math_polynomials', 'math_factoring']
              },
              math_polynomials: {
                id: 'math_polynomials',
                name: 'Polynomials',
                type: 'small',
                x: 200,
                y: 0,
                description: 'Working with polynomial expressions',
                requirements: { tasksCompleted: 7 },
                connections: []
              },
              math_factoring: {
                id: 'math_factoring',
                name: 'Factoring',
                type: 'small',
                x: 200,
                y: 100,
                description: 'Factoring techniques and methods',
                requirements: { tasksCompleted: 7 },
                connections: []
              }
            }
          },
          programming: {
            nodes: {
              prog_start: {
                id: 'prog_start',
                name: 'Programming Basics',
                type: 'keystone',
                x: 0,
                y: 0,
                description: 'The foundation of programming knowledge',
                requirements: { tasksCompleted: 0 },
                connections: ['prog_syntax', 'prog_variables']
              },
              prog_syntax: {
                id: 'prog_syntax',
                name: 'Syntax',
                type: 'small',
                x: -100,
                y: -50,
                description: 'Understanding programming syntax',
                requirements: { tasksCompleted: 1 },
                connections: ['prog_operators']
              },
              prog_operators: {
                id: 'prog_operators',
                name: 'Operators',
                type: 'small',
                x: -150,
                y: -100,
                description: 'Mathematical and logical operators',
                requirements: { tasksCompleted: 2 },
                connections: []
              },
              prog_variables: {
                id: 'prog_variables',
                name: 'Variables',
                type: 'small',
                x: -100,
                y: 50,
                description: 'Variable declaration and usage',
                requirements: { tasksCompleted: 1 },
                connections: ['prog_data_types']
              },
              prog_data_types: {
                id: 'prog_data_types',
                name: 'Data Types',
                type: 'small',
                x: -150,
                y: 100,
                description: 'Understanding different data types',
                requirements: { tasksCompleted: 2 },
                connections: []
              },
              prog_control_branch: {
                id: 'prog_control_branch',
                name: 'Control Flow',
                type: 'notable',
                x: 100,
                y: 0,
                description: 'Program flow and decision making',
                requirements: { tasksCompleted: 3 },
                connections: ['prog_conditionals', 'prog_loops']
              },
              prog_conditionals: {
                id: 'prog_conditionals',
                name: 'Conditionals',
                type: 'small',
                x: 150,
                y: -50,
                description: 'If/else statements and branching',
                requirements: { tasksCompleted: 4 },
                connections: []
              },
              prog_loops: {
                id: 'prog_loops',
                name: 'Loops',
                type: 'small',
                x: 150,
                y: 50,
                description: 'Iteration and repetition',
                requirements: { tasksCompleted: 4 },
                connections: []
              }
            }
          }
        };

        const currentTree = poeSkillTree[activeSubject];
        if (!currentTree) return <div>No skill tree available for this subject.</div>;

        const handleMouseDown = (e) => {
          // Only start dragging if clicking on empty space, not on nodes
          if (e.target.tagName === 'svg' || (e.target.tagName === 'g' && e.target.classList.contains('grid-group'))) {
            setDragging(true);
            setDragStart({ x: e.clientX - panX, y: e.clientY - panY });
          }
        };

        const handleMouseMove = (e) => {
          if (dragging) {
            setPanX(e.clientX - dragStart.x);
            setPanY(e.clientY - dragStart.y);
          }
        };

        const handleMouseUp = () => {
          setDragging(false);
        };

        const handleWheel = (e) => {
          e.preventDefault();
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          setZoom(Math.max(0.5, Math.min(2, zoom * delta)));
        };

        const getNodeStyle = (node) => {
          const isUnlocked = XP_SYSTEM.isSkillUnlocked(node, { 
            tasksCompleted: log.filter(e => e.type === "task").length 
          });
          
          let baseStyle = {
            r: node.type === 'keystone' ? 20 : node.type === 'notable' ? 15 : 10,
            fill: isUnlocked ? '#10B981' : '#6B7280',
            stroke: isUnlocked ? '#059669' : '#4B5563',
            strokeWidth: 2
          };

          if (hoveredNode === node.id) {
            baseStyle.strokeWidth = 3;
            baseStyle.stroke = '#3B82F6';
          }

          return baseStyle;
        };

        const getConnectionPath = (fromNode, toNode) => {
          const x1 = fromNode.x;
          const y1 = fromNode.y;
          const x2 = toNode.x;
          const y2 = toNode.y;
          
          const midX = (x1 + x2) / 2;
          const midY = (y1 + y2) / 2;
          
          return `M ${x1} ${y1} Q ${midX} ${midY} ${x2} ${y2}`;
        };

        // Calculate viewport bounds for better navigation
        const getViewportBounds = () => {
          const bounds = { minX: 0, maxX: 0, minY: 0, maxY: 0 };
          Object.values(currentTree.nodes).forEach(node => {
            bounds.minX = Math.min(bounds.minX, node.x);
            bounds.maxX = Math.max(bounds.maxX, node.x);
            bounds.minY = Math.min(bounds.minY, node.y);
            bounds.maxY = Math.max(bounds.maxY, node.y);
          });
          return bounds;
        };

        const bounds = getViewportBounds();

        return (
          <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 overflow-hidden">
            <div className="p-4 border-b border-neutral-800 flex items-center justify-between">
              <h2 className="text-xl font-semibold">
                {SUBJECTS[activeSubject]?.icon} {SUBJECTS[activeSubject]?.name} - Path of Exile Style
              </h2>
              <div className="flex items-center gap-4">
                <div className="text-sm text-neutral-400">
                  Zoom: {Math.round(zoom * 100)}%
                </div>
                <div className="flex items-center gap-2">
                  <button
                    onClick={() => {
                      setZoom(1);
                      setPanX(0);
                      setPanY(0);
                    }}
                    className="px-3 py-1 rounded bg-neutral-800 hover:bg-neutral-700 text-sm"
                  >
                    Reset View
                  </button>
                  <button
                    onClick={() => {
                      // Center the view on all nodes
                      const centerX = (bounds.minX + bounds.maxX) / 2;
                      const centerY = (bounds.minY + bounds.maxY) / 2;
                      setPanX(-centerX);
                      setPanY(-centerY);
                      setZoom(1);
                    }}
                    className="px-3 py-1 rounded bg-neutral-800 hover:bg-neutral-700 text-sm"
                  >
                    Center View
                  </button>
                </div>
              </div>
            </div>

            <div className="relative h-[600px] bg-neutral-950 overflow-hidden">
              <svg
                width="100%"
                height="100%"
                viewBox={`${bounds.minX - 100} ${bounds.minY - 100} ${bounds.maxX - bounds.minX + 200} ${bounds.maxY - bounds.minY + 200}`}
                onMouseDown={handleMouseDown}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onWheel={handleWheel}
                style={{ cursor: dragging ? 'grabbing' : 'grab' }}
              >
                <defs>
                  <pattern id={`grid-${activeSubject}`} width="50" height="50" patternUnits="userSpaceOnUse">
                    <path d="M 50 0 L 0 0 0 50" fill="none" stroke="#374151" strokeWidth="0.5" opacity="0.3"/>
                  </pattern>
                </defs>
                
                {/* Grid background */}
                <rect 
                  x={bounds.minX - 100} 
                  y={bounds.minY - 100} 
                  width={bounds.maxX - bounds.minX + 200} 
                  height={bounds.maxY - bounds.minY + 200} 
                  fill={`url(#grid-${activeSubject})`} 
                />
                
                <g transform={`translate(${panX}, ${panY}) scale(${zoom})`}>
                  {/* Connection lines */}
                  {Object.values(currentTree.nodes).map(node => 
                    node.connections?.map(connectionId => {
                      const connectedNode = currentTree.nodes[connectionId];
                      if (!connectedNode) return null;
                      
                      const isFromUnlocked = XP_SYSTEM.isSkillUnlocked(node, { 
                        tasksCompleted: log.filter(e => e.type === "task").length 
                      });
                      const isToUnlocked = XP_SYSTEM.isSkillUnlocked(connectedNode, { 
                        tasksCompleted: log.filter(e => e.type === "task").length 
                      });
                      
                      return (
                        <path
                          key={`${node.id}-${connectionId}`}
                          d={getConnectionPath(node, connectedNode)}
                          stroke={isFromUnlocked && isToUnlocked ? '#10B981' : '#6B7280'}
                          strokeWidth="2"
                          fill="none"
                          opacity="0.6"
                        />
                      );
                    })
                  )}
                  
                  {/* Skill nodes */}
                  {Object.values(currentTree.nodes).map(node => {
                    const isUnlocked = XP_SYSTEM.isSkillUnlocked(node, { 
                      tasksCompleted: log.filter(e => e.type === "task").length 
                    });
                    
                    return (
                      <g key={node.id} className="skill-node">
                        <circle
                          cx={node.x}
                          cy={node.y}
                          {...getNodeStyle(node)}
                          onMouseEnter={() => setHoveredNode(node.id)}
                          onMouseLeave={() => setHoveredNode(null)}
                          onClick={(e) => {
                            e.stopPropagation(); // Prevent dragging when clicking nodes
                            if (isUnlocked) {
                              try {
                                setForm(prev => ({
                                  ...prev,
                                  subject: activeSubject,
                                  mainSkill: node.id,
                                  subSkill: node.id
                                }));
                                setActiveTab('tasks');
                              } catch (error) {
                                console.error('Error switching to tasks tab:', error);
                              }
                            }
                          }}
                          style={{ cursor: isUnlocked ? 'pointer' : 'not-allowed' }}
                        />
                        
                        {/* Node type indicator */}
                        {node.type === 'keystone' && (
                          <text
                            x={node.x}
                            y={node.y - 25}
                            textAnchor="middle"
                            className="text-xs fill-white font-bold pointer-events-none"
                          >
                            ★
                          </text>
                        )}
                        {node.type === 'notable' && (
                          <text
                            x={node.x}
                            y={node.y - 20}
                            textAnchor="middle"
                            className="text-xs fill-white font-bold pointer-events-none"
                          >
                            ◆
                          </text>
                        )}
                        
                        {/* Node label */}
                        <text
                          x={node.x}
                          y={node.y + 35}
                          textAnchor="middle"
                          className="text-xs fill-neutral-300 pointer-events-none"
                          style={{ fontSize: '10px' }}
                        >
                          {node.name}
                        </text>
                      </g>
                    );
                  })}
                </g>
              </svg>
            </div>

            {/* Node tooltip */}
            {hoveredNode && currentTree.nodes[hoveredNode] && (
              <div className="absolute bottom-4 left-4 bg-neutral-800 border border-neutral-700 rounded-lg p-3 max-w-xs z-10">
                <div className="font-semibold text-sm mb-1">
                  {currentTree.nodes[hoveredNode].name}
                </div>
                <div className="text-xs text-neutral-400 mb-2">
                  {currentTree.nodes[hoveredNode].description}
                </div>
                <div className="text-xs text-amber-400">
                  Requires: {currentTree.nodes[hoveredNode].requirements.tasksCompleted} tasks completed
                </div>
              </div>
            )}

            {/* Controls */}
            <div className="p-4 border-t border-neutral-800">
              <div className="text-sm text-neutral-400">
                <div className="mb-2">🎮 Path of Exile Style Controls:</div>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-2 text-xs">
                  <div>• Click and drag on empty space to pan</div>
                  <div>• Mouse wheel to zoom in/out (50%-200%)</div>
                  <div>• Click on unlocked green nodes to create tasks</div>
                  <div>• Hover over nodes to see detailed information</div>
                </div>
                <div className="mt-3 grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <div className="text-xs font-semibold mb-1">Node Types:</div>
                    <div className="text-xs space-y-1">
                      <div><span className="text-emerald-400">●</span> Small Skills (Basic abilities)</div>
                      <div><span className="text-blue-400">◆</span> Notable Skills (Important milestones)</div>
                      <div><span className="text-yellow-400">★</span> Keystone Skills (Major game-changers)</div>
                    </div>
                  </div>
                  <div>
                    <div className="text-xs font-semibold mb-1">Node States:</div>
                    <div className="text-xs space-y-1">
                      <div><span className="text-emerald-400">●</span> Green = Unlocked (can create tasks)</div>
                      <div><span className="text-gray-400">●</span> Gray = Locked (need prerequisites)</div>
                      <div><span className="text-blue-400">●</span> Blue = Hovered (showing details)</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        );
      }

      function CalendarTab({ tasks, projects, completeTask, deleteTask, todayISO, SUBJECTS }) {
        const [calendarView, setCalendarView] = useState('daily'); // 'daily' or 'weekly'
        const [selectedDate, setSelectedDate] = useState(todayISO());
        
        // Generate week dates
        const getWeekDates = (date) => {
          const d = new Date(date + 'T00:00:00');
          const day = d.getDay();
          const diff = d.getDate() - day;
          const weekStart = new Date(d.setDate(diff));
          const week = [];
          for (let i = 0; i < 7; i++) {
            const weekDate = new Date(weekStart);
            weekDate.setDate(weekStart.getDate() + i);
            week.push(weekDate.toISOString().split('T')[0]);
          }
          return week;
        };

        const weekDates = getWeekDates(selectedDate);
        const today = todayISO();

        // Get tasks for a specific date
        const getTasksForDate = (date) => {
          return tasks.filter(task => {
            // For now, show all tasks for any date
            // In the future, we could add scheduled dates to tasks
            return true;
          });
        };

        // Get projects for a specific date
        const getProjectsForDate = (date) => {
          return projects.filter(project => {
            if (project.completedAt) return false;
            if (!project.dueDate) return false;
            return project.dueDate === date;
          });
        };

        // Time slots for daily view
        const timeSlots = Array.from({ length: 24 }, (_, i) => i);

        return (
          <div className="space-y-6">
            {/* Calendar Controls */}
            <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-xl font-semibold">Calendar View</h2>
                <div className="flex items-center gap-3">
                  <select 
                    value={calendarView} 
                    onChange={e => setCalendarView(e.target.value)}
                    className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                  >
                    <option value="daily">Daily View</option>
                    <option value="weekly">Weekly View</option>
                  </select>
                  <input 
                    type="date" 
                    value={selectedDate} 
                    onChange={e => setSelectedDate(e.target.value)}
                    className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                  />
                </div>
              </div>
            </div>

            {calendarView === 'daily' && (
              <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 overflow-hidden">
                <div className="p-5 border-b border-neutral-800">
                  <h3 className="text-lg font-semibold">
                    {new Date(selectedDate + 'T00:00:00').toLocaleDateString('en-US', { 
                      weekday: 'long', 
                      year: 'numeric', 
                      month: 'long', 
                      day: 'numeric' 
                    })}
                  </h3>
                  <div className="text-sm text-neutral-400 mt-1">
                    {getTasksForDate(selectedDate).length} tasks • {getProjectsForDate(selectedDate).length} projects due
                  </div>
                </div>

                <div className="grid grid-cols-25 gap-0">
                  {/* Time column */}
                  <div className="bg-neutral-800 border-r border-neutral-700 p-2 text-xs text-neutral-400 font-semibold">
                    Time
                  </div>
                  
                  {/* Task column */}
                  <div className="col-span-24 bg-neutral-800 border-r border-neutral-700 p-2 text-xs text-neutral-400 font-semibold">
                    Tasks & Projects
                  </div>

                  {/* Time slots */}
                  {timeSlots.map(hour => {
                    const tasksForHour = getTasksForDate(selectedDate);
                    const projectsForHour = getProjectsForDate(selectedDate);
                    
                    return (
                      <React.Fragment key={hour}>
                        <div className="bg-neutral-800 border-r border-neutral-700 border-t border-neutral-700 p-2 text-xs text-neutral-500">
                          {hour.toString().padStart(2, '0')}:00
                        </div>
                        <div className="col-span-24 bg-neutral-900 border-t border-neutral-700 p-2 min-h-[60px]">
                          {hour === 9 && tasksForHour.length > 0 && (
                            <div className="space-y-2">
                              {tasksForHour.slice(0, 3).map(task => {
                                const completed = (task.timesCompletedToday || 0) > 0;
                                return (
                                  <div key={task.id} className={`p-2 rounded-lg border ${
                                    completed 
                                      ? 'bg-green-900/30 border-green-800' 
                                      : 'bg-neutral-800 border-neutral-700'
                                  }`}>
                                    <div className="flex items-center justify-between">
                                      <div className="flex items-center gap-2">
                                        <span className="text-sm">{SUBJECTS[task.subject]?.icon}</span>
                                        <span className={`text-sm ${completed ? 'line-through text-neutral-400' : ''}`}>
                                          {task.title}
                                        </span>
                                      </div>
                                      <div className="flex items-center gap-1">
                                        <button 
                                          onClick={() => completeTask(task.id)}
                                          disabled={completed}
                                          className={`px-2 py-1 rounded text-xs ${
                                            completed 
                                              ? 'bg-neutral-700 text-neutral-500' 
                                              : 'bg-emerald-600 hover:bg-emerald-500 text-white'
                                          }`}
                                        >
                                          {completed ? '✓' : 'Complete'}
                                        </button>
                                      </div>
                                    </div>
                                    <div className="text-xs text-neutral-400 mt-1">
                                      {task.subSkillName} • {task.baseXP} XP • Est {task.estimateMin || 0} min
                                    </div>
                                  </div>
                                );
                              })}
                              {tasksForHour.length > 3 && (
                                <div className="text-xs text-neutral-500">
                                  +{tasksForHour.length - 3} more tasks
                                </div>
                              )}
                            </div>
                          )}
                          
                          {hour === 14 && projectsForHour.length > 0 && (
                            <div className="space-y-2">
                              {projectsForHour.map(project => (
                                <div key={project.id} className="p-2 rounded-lg bg-indigo-900/30 border border-indigo-800">
                                  <div className="flex items-center gap-2">
                                    <span className="text-sm">🎯</span>
                                    <span className="text-sm font-semibold">{project.title}</span>
                                  </div>
                                  <div className="text-xs text-neutral-400 mt-1">
                                    Due today • {project.rewardXP} XP reward
                                  </div>
                                </div>
                              ))}
                            </div>
                          )}
                        </div>
                      </React.Fragment>
                    );
                  })}
                </div>
              </div>
            )}

            {calendarView === 'weekly' && (
              <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 overflow-hidden">
                <div className="p-5 border-b border-neutral-800">
                  <h3 className="text-lg font-semibold">
                    Week of {new Date(weekDates[0] + 'T00:00:00').toLocaleDateString('en-US', { 
                      month: 'short', 
                      day: 'numeric' 
                    })} - {new Date(weekDates[6] + 'T00:00:00').toLocaleDateString('en-US', { 
                      month: 'short', 
                      day: 'numeric',
                      year: 'numeric'
                    })}
                  </h3>
                </div>

                <div className="grid grid-cols-8 gap-0">
                  {/* Header row */}
                  <div className="bg-neutral-800 border-r border-neutral-700 p-3 text-xs text-neutral-400 font-semibold">
                    Time
                  </div>
                  {weekDates.map(date => (
                    <div key={date} className="bg-neutral-800 border-r border-neutral-700 p-3 text-center">
                      <div className={`text-sm font-semibold ${
                        date === today ? 'text-emerald-400' : 'text-neutral-200'
                      }`}>
                        {new Date(date + 'T00:00:00').toLocaleDateString('en-US', { weekday: 'short' })}
                      </div>
                      <div className={`text-xs ${
                        date === today ? 'text-emerald-300' : 'text-neutral-400'
                      }`}>
                        {new Date(date + 'T00:00:00').getDate()}
                      </div>
                    </div>
                  ))}

                  {/* Task rows - simplified for weekly view */}
                  {['Morning', 'Afternoon', 'Evening'].map(period => (
                    <React.Fragment key={period}>
                      <div className="bg-neutral-800 border-r border-neutral-700 border-t border-neutral-700 p-3 text-xs text-neutral-500 font-semibold">
                        {period}
                      </div>
                      {weekDates.map(date => {
                        const dayTasks = getTasksForDate(date);
                        const dayProjects = getProjectsForDate(date);
                        
                        return (
                          <div key={date} className="bg-neutral-900 border-r border-neutral-700 border-t border-neutral-700 p-2 min-h-[80px]">
                            {period === 'Morning' && (
                              <div className="space-y-1">
                                {dayTasks.slice(0, 2).map(task => {
                                  const completed = (task.timesCompletedToday || 0) > 0;
                                  return (
                                    <div key={task.id} className={`p-1 rounded text-xs ${
                                      completed ? 'bg-green-900/30 text-green-200' : 'bg-neutral-800 text-neutral-300'
                                    }`}>
                                      <div className="flex items-center gap-1">
                                        <span>{SUBJECTS[task.subject]?.icon}</span>
                                        <span className="truncate">{task.title}</span>
                                      </div>
                                    </div>
                                  );
                                })}
                              </div>
                            )}
                            
                            {period === 'Afternoon' && dayProjects.length > 0 && (
                              <div className="space-y-1">
                                {dayProjects.slice(0, 1).map(project => (
                                  <div key={project.id} className="p-1 rounded bg-indigo-900/30 text-indigo-200 text-xs">
                                    <div className="flex items-center gap-1">
                                      <span>🎯</span>
                                      <span className="truncate">{project.title}</span>
                                    </div>
                                  </div>
                                ))}
                              </div>
                            )}
                          </div>
                        );
                      })}
                    </React.Fragment>
                  ))}
                </div>
              </div>
            )}
          </div>
        );
      }

      function ProjectsTab({ 
        projects, setProjects, projForm, setProjForm, addProject, deleteProject, 
        addProjectStep, toggleStep, todayISO, uid 
      }) {
        return (
          <div className="space-y-6">
            {/* Add Project Form */}
            <form onSubmit={addProject} className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5">
              <h2 className="text-xl font-semibold mb-4">Add New Project</h2>
              
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3 mb-4">
                <input 
                  className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                  placeholder="Project title (e.g., Learn Integral Calculus)"
                  value={projForm.title} 
                  onChange={e=> setProjForm({...projForm, title:e.target.value})} 
                />
                
                <select 
                  className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                  value={projForm.subject} 
                  onChange={e=> {
                    const newSubject = e.target.value;
                    const subjectTree = SKILL_TREES[newSubject];
                    const firstMainSkill = Object.keys(subjectTree.mainSkills)[0];
                    const firstSubSkill = Object.keys(subjectTree.mainSkills[firstMainSkill].subSkills)[0];
                    setProjForm({
                      ...projForm, 
                      subject: newSubject,
                      mainSkill: firstMainSkill,
                      subSkill: firstSubSkill
                    });
                  }}
                >
                  {Object.entries(SUBJECTS).map(([id, subject]) => (
                    <option key={id} value={id}>{subject.icon} {subject.name}</option>
                  ))}
                </select>
                
                <select 
                  className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                  value={projForm.mainSkill} 
                  onChange={e=> {
                    const newMainSkill = e.target.value;
                    const firstSubSkill = Object.keys(SKILL_TREES[projForm.subject].mainSkills[newMainSkill].subSkills)[0];
                    setProjForm({...projForm, mainSkill: newMainSkill, subSkill: firstSubSkill});
                  }}
                >
                  {projForm.subject && Object.entries(SKILL_TREES[projForm.subject].mainSkills).map(([id, skill]) => (
                    <option key={id} value={id}>{skill.name}</option>
                  ))}
                </select>
                
                <select 
                  className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                  value={projForm.subSkill} 
                  onChange={e=> setProjForm({...projForm, subSkill:e.target.value})}
                >
                  {projForm.subject && projForm.mainSkill && Object.entries(SKILL_TREES[projForm.subject].mainSkills[projForm.mainSkill].subSkills).map(([id, skill]) => (
                    <option key={id} value={id}>{skill.name}</option>
                  ))}
                </select>
              </div>
              
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-3">
                <input 
                  className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                  placeholder="Short description"
                  value={projForm.description} 
                  onChange={e=> setProjForm({...projForm, description:e.target.value})} 
                />
                <input 
                  type="date" 
                  className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                  value={projForm.dueDate} 
                  onChange={e=> setProjForm({...projForm, dueDate:e.target.value})} 
                />
                <label className="flex items-center gap-2 text-sm text-neutral-300 bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2">
                  <input 
                    type="checkbox" 
                    className="accent-emerald-600"
                    checked={projForm.committed} 
                    onChange={e=> setProjForm({...projForm, committed:e.target.checked})} 
                  />
                  Commit deadline
                </label>
                <input 
                  type="number" 
                  min="1" 
                  className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                  placeholder="Reward XP (e.g., 1000)" 
                  value={projForm.rewardXP}
                  onChange={e=> setProjForm({...projForm, rewardXP:e.target.value})} 
                />
                <button className="bg-indigo-600 hover:bg-indigo-500 text-white rounded-xl px-4 py-2 font-semibold shadow">
                  Add Project
                </button>
              </div>
            </form>

            {/* Projects List */}
            <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 divide-y divide-neutral-800 overflow-hidden">
              {projects.length===0 ? (
                <div className="p-6 text-neutral-400">No projects yet. Add a challenge above, then add steps.</div>
              ) : (
                projects.map(p=>{
                  const total=p.steps.length; 
                  const done=p.steps.filter(s=>s.done).length;
                  const pct = total===0 ? 0 : Math.round((done/total)*100);
                  const completed = !!p.completedAt;

                  // Bonus preview (approximate)
                  let preview="";
                  if (p.dueDate && !completed){
                    const due = new Date(p.dueDate+"T00:00:00");
                    const diff = Math.floor((due - new Date())/86400000);
                    if (diff>=1)      preview = `Early bonus up to +${Math.min(25, diff*4)}% (${Math.min(25, diff*4)}% if finished today)`;
                    else if (Math.abs(diff)<=1) preview = "On-time bonus +10%";
                    else               preview = "Late (no deadline bonus)";
                  }

                  return (
                    <div key={p.id} className="p-4">
                      <div className="flex items-start justify-between gap-4">
                        <div className="flex-1">
                          <div className="flex items-center gap-2">
                            <div className="text-lg font-semibold">{p.title}</div>
                            {completed && (
                              <span className="text-xs px-2 py-0.5 rounded-full bg-emerald-900/50 text-emerald-200 border border-emerald-800">
                                Completed • {p.completedAt}
                              </span>
                            )}
                          </div>
                          {p.description && (
                            <div className="text-sm text-neutral-300 mt-1">{p.description}</div>
                          )}
                          <div className="mt-2 text-xs text-neutral-400">
                            Reward {p.rewardXP} XP {p.dueDate && <>• Due {p.dueDate} {p.committed && <span className="text-emerald-300">• committed</span>}</>}
                            {p.subSkillName && (
                              <div className="mt-1">
                                <span className="text-blue-300">{SUBJECTS[p.subject]?.icon} {SUBJECTS[p.subject]?.name}</span>
                                <span className="text-neutral-500"> • </span>
                                <span className="text-emerald-300">{p.subSkillName}</span>
                              </div>
                            )}
                          </div>
                          {preview && !completed && <div className="mt-1 text-xs text-indigo-300">{preview}</div>}
                          <div className="mt-3">
                            <div className="w-full h-2 bg-neutral-800 rounded-full overflow-hidden">
                              <div className="h-full bg-indigo-500" style={{ width: `${pct}%` }} />
                            </div>
                            <div className="mt-1 text-xs text-neutral-400">{done}/{total} steps</div>
                          </div>
                        </div>
                        <div className="flex flex-col items-end gap-2 min-w-[180px]">
                          <button onClick={()=> deleteProject(p.id)}
                            className="px-3 py-2 rounded-xl text-sm font-semibold bg-rose-900/60 hover:bg-rose-800 text-rose-100 shadow">
                            Delete Project
                          </button>
                        </div>
                      </div>

                      <div className="mt-4 space-y-2">
                        {p.steps.length===0 ? (
                          <div className="text-sm text-neutral-400">No steps yet. Add steps below.</div>
                        ) : (
                          p.steps.map(s=>(
                            <label key={s.id} className="flex items-start gap-3 p-2 rounded-xl hover:bg-neutral-800 cursor-pointer">
                              <input 
                                type="checkbox" 
                                className="mt-1 h-4 w-4 accent-indigo-600"
                                checked={s.done} 
                                onChange={()=> toggleStep(p.id, s.id)} 
                                disabled={Boolean(p.completedAt)} 
                              />
                              <span className={`text-sm ${s.done ? "line-through text-neutral-500" : "text-neutral-100"}`}>
                                {s.title}
                              </span>
                              {s.doneAtDate && <span className="ml-auto text-xs text-neutral-500">done {s.doneAtDate}</span>}
                            </label>
                          ))
                        )}
                      </div>

                      {!p.completedAt && (
                        <AddStepInline onAdd={(title)=> addProjectStep(p.id, title)} />
                      )}
                    </div>
                  );
                })
              )}
            </div>
          </div>
        );
      }

      function AnalyticsTab({ 
        productivityInsights, weekMetrics, completedToday, totalBaseXpToday, 
        skillMods, currentTitles, challengeData, checkChallengeProgress, 
        challenges, completeChallenge, templates, showTemplates, setShowTemplates,
        applyTemplate, createCustomTemplate, getSmartSuggestion, form, showSmartScheduling,
        setShowSmartScheduling, SMART_SCHEDULING 
      }) {
        const { tasksMult, passiveMult, projectMult, baseFlat, streakCap } = skillMods;
        
        return (
          <div className="space-y-6">
            {/* Productivity Insights */}
            <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5">
              <h2 className="text-xl font-semibold mb-3">Productivity Insights</h2>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div>
                  <h3 className="text-lg font-semibold mb-3 text-emerald-400">Best Times to Work</h3>
                  {productivityInsights.bestHours.length > 0 ? (
                    <div className="space-y-2">
                      {productivityInsights.bestHours.map((stat, i) => (
                        <div key={i} className="flex justify-between items-center p-2 bg-neutral-800 rounded-lg">
                          <span className="text-sm">{stat.hour}:00 - {stat.hour + 1}:00</span>
                          <span className="text-xs text-neutral-400">{stat.count} tasks • {stat.avgXP.toFixed(0)} avg XP</span>
                        </div>
                      ))}
                    </div>
                  ) : (
                    <div className="text-sm text-neutral-500">Complete more tasks to see patterns</div>
                  )}
                </div>
                
                <div>
                  <h3 className="text-lg font-semibold mb-3 text-indigo-400">Top Categories</h3>
                  {productivityInsights.topCategories.length > 0 ? (
                    <div className="space-y-2">
                      {productivityInsights.topCategories.map((stat, i) => (
                        <div key={i} className="flex justify-between items-center p-2 bg-neutral-800 rounded-lg">
                          <span className="text-sm">{stat.category}</span>
                          <span className="text-xs text-neutral-400">{stat.count} tasks • {stat.avgXP.toFixed(0)} avg XP</span>
                        </div>
                      ))}
                    </div>
                  ) : (
                    <div className="text-sm text-neutral-500">Complete more tasks to see patterns</div>
                  )}
                </div>
                
                <div>
                  <h3 className="text-lg font-semibold mb-3 text-violet-400">Best Days</h3>
                  {productivityInsights.bestDays.length > 0 ? (
                    <div className="space-y-2">
                      {productivityInsights.bestDays.map((stat, i) => (
                        <div key={i} className="flex justify-between items-center p-2 bg-neutral-800 rounded-lg">
                          <span className="text-sm">{stat.day}</span>
                          <span className="text-xs text-neutral-400">{stat.count} tasks • {stat.avgXP.toFixed(0)} avg XP</span>
                        </div>
                      ))}
                    </div>
                  ) : (
                    <div className="text-sm text-neutral-500">Complete more tasks to see patterns</div>
                  )}
                </div>
              </div>
            </div>
            
            <div className="text-neutral-400">More analytics coming soon...</div>
          </div>
        );
      }

      // ================== Main App ==================
      function LifeXPApp() {
        // Cloud backup instance
        const [cloudBackup] = useState(() => new CloudBackup());
        const [user, setUser] = useState(null);
        const [showAuth, setShowAuth] = useState(false);
        const [authMode, setAuthMode] = useState('login'); // 'login' or 'register'
        const [authForm, setAuthForm] = useState({ email: '', password: '', confirmPassword: '' });
        const [isSyncing, setIsSyncing] = useState(false);

        // Core state
        const [tasks, setTasks] = useLocalStorage("lifexp.tasks", []);
        const [projects, setProjects] = useLocalStorage("lifexp.projects", []);
        const [xp, setXp] = useLocalStorage("lifexp.xp", 0);
        const [skill, setSkill] = useLocalStorage("lifexp.skill", { points: 0, upgrades: {} });
        const [lastLevel, setLastLevel] = useLocalStorage("lifexp.lastLevel", 0);
        const [milestones, setMilestones] = useLocalStorage("lifexp.milestones", { claimed: [] });
        const [achievements, setAchievements] = useLocalStorage("lifexp.achievements", { unlocked: [] });
        const [xpLearning, setXpLearning] = useLocalStorage("lifexp.xpLearning", { 
          userAdjustments: {}, // Track user's manual XP adjustments
          categoryPatterns: {}, // Learn category-specific patterns
          difficultyPatterns: {}, // Learn difficulty patterns
          timePatterns: {} // Learn time-based patterns
        });
        
        // ML System State
        const [mlData, setMlData] = useLocalStorage("lifexp.mlData", {
          patterns: {},
          learning: { categoryBias: {}, difficultyBias: {}, timeBias: {}, confidence: 0.5 },
          insights: [],
          lastAnalysis: null
        });

        // Dual-Track System State
        const [dualTrackData, setDualTrackData] = useLocalStorage("lifexp.dualTrack", {
          // Mastery Track (Intrinsic - Evidence-Based)
          mastery: {
            subjects: {},
            evidence: [],
            unlocks: {},
            progression: {}
          },
          
          // Momentum Track (Extrinsic - Level-Based)
          momentum: {
            level: 1,
            xp: 0,
            xpToNext: 500,
            unbankedXP: 0,
            coins: 0,
            lastBankTime: null,
            streak: 0
          },
          
          // User Progressions
          progression: {
            lastLevelUp: null,
            totalTasksCompleted: 0,
            dailyTasksCompleted: 0,
            weeklyTasksCompleted: 0,
            masteryMilestones: []
          }
        });
        const [dateInfo, setDateInfo] = useLocalStorage("lifexp.dateInfo", { lastOpen: todayISO() });
        const [log, setLog] = useLocalStorage("lifexp.log", []); // {id,date,ts,type,amount,meta}
        const [session, setSession] = useLocalStorage("lifexp.session", null); // passive focus running

        // NEW: Dual XP and Skill Tree state
        const [subjectXP, setSubjectXP] = useLocalStorage("lifexp.subjectXP", {
          math: 0,
          programming: 0,
          economics: 0,
          history: 0
        });
        const [subSkillProgress, setSubSkillProgress] = useLocalStorage("lifexp.subSkillProgress", {});
        const [activeTab, setActiveTab] = useLocalStorage("lifexp.activeTab", "tasks");
        const [activeSubject, setActiveSubject] = useState("math");

        // NEW: Challenge and template state
        const [challenges, setChallenges] = useLocalStorage("lifexp.challenges", { 
          daily: { completed: [], lastReset: todayISO() },
          weekly: { completed: [], lastReset: isoWeekKey() }
        });
        const [templates, setTemplates] = useLocalStorage("lifexp.templates", TASK_TEMPLATES);
        const [currentTitles, setCurrentTitles] = useLocalStorage("lifexp.titles", { 
          level: "Novice", 
          branch: {}, 
          achievement: [], 
          special: [] 
        });

        // Settings (dark, caps)
        const DEFAULT_CAPS = { total: 200, perCat: 100 };
        const [theme, setTheme] = useLocalStorage("lifexp.theme", "dark"); // "dark" | "light"
        const [settings, setSettings] = useLocalStorage("lifexp.settings", {
          capMode: "dynamic", // "static" | "dynamic"
          staticTotal: DEFAULT_CAPS.total,
          staticPerCat: DEFAULT_CAPS.perCat,
          autoXPMode: true, // Enable automatic XP calculation
          userLevel: 5, // User's overall skill level (1-10)
        });

        // UI misc
        const [alerts, setAlerts] = useState([]);
        const [showTemplates, setShowTemplates] = useState(false);
        const [showSmartScheduling, setShowSmartScheduling] = useState(false);

        // Theme effect
        useEffect(()=>{
          const el = document.documentElement;
          if (theme === "dark") el.classList.add("dark"); else el.classList.remove("dark");
        }, [theme]);

        // Authentication state listener
        useEffect(() => {
          if (window.firebaseAuthMethods) {
            const unsubscribe = window.firebaseAuthMethods.onAuthStateChanged(window.firebaseAuth, (user) => {
              setUser(user);
              cloudBackup.user = user;
              if (user) {
                // Auto-sync when user logs in
                syncWithCloud();
              }
            });
            return () => unsubscribe();
          }
        }, []);

        // Sync with cloud
        const syncWithCloud = async () => {
          if (!cloudBackup.isAuthenticated()) return;
          
          setIsSyncing(true);
          try {
            const currentData = {
              tasks, projects, xp, skill, lastLevel, milestones, achievements, xpLearning, mlData, dualTrackData, dateInfo, log, settings, theme, challenges, templates, currentTitles, subjectXP, subSkillProgress, activeTab
            };
            
            const syncedData = await cloudBackup.syncData(currentData);
            
            // Update local state with synced data
            if (syncedData.tasks) setTasks(syncedData.tasks);
            if (syncedData.projects) setProjects(syncedData.projects);
            if (syncedData.xp !== undefined) setXp(syncedData.xp);
            if (syncedData.skill) setSkill(syncedData.skill);
            if (syncedData.lastLevel !== undefined) setLastLevel(syncedData.lastLevel);
            if (syncedData.milestones) setMilestones(syncedData.milestones);
            if (syncedData.achievements) setAchievements(syncedData.achievements);
            if (syncedData.xpLearning) setXpLearning(syncedData.xpLearning);
            if (syncedData.mlData) setMlData(syncedData.mlData);
            if (syncedData.dualTrackData) setDualTrackData(syncedData.dualTrackData);
            if (syncedData.dateInfo) setDateInfo(syncedData.dateInfo);
            if (syncedData.log) setLog(syncedData.log);
            if (syncedData.settings) setSettings(syncedData.settings);
            if (syncedData.theme) setTheme(syncedData.theme);
            if (syncedData.challenges) setChallenges(syncedData.challenges);
            if (syncedData.templates) setTemplates(syncedData.templates);
            if (syncedData.currentTitles) setCurrentTitles(syncedData.currentTitles);
            if (syncedData.subjectXP) setSubjectXP(syncedData.subjectXP);
            if (syncedData.subSkillProgress) setSubSkillProgress(syncedData.subSkillProgress);
            if (syncedData.activeTab) setActiveTab(syncedData.activeTab);
            
            pushAlert("Data synced with cloud ✓");
          } catch (error) {
            pushAlert("Sync failed - using local data", "error");
          } finally {
            setIsSyncing(false);
          }
        };

        // Auto-save to cloud when data changes
        useEffect(() => {
          if (cloudBackup.isAuthenticated() && !isSyncing) {
            const timeoutId = setTimeout(() => {
              const currentData = {
                tasks, projects, xp, skill, lastLevel, milestones, achievements, xpLearning, mlData, dualTrackData, dateInfo, log, settings, theme, challenges, templates, currentTitles, subjectXP, subSkillProgress, activeTab
              };
              cloudBackup.syncData(currentData);
            }, 2000); // Debounce for 2 seconds
            
            return () => clearTimeout(timeoutId);
          }
        }, [tasks, projects, xp, skill, lastLevel, milestones, achievements, xpLearning, mlData, dualTrackData, dateInfo, log, settings, theme, challenges, templates, currentTitles, subjectXP, subSkillProgress, activeTab]);

        // Authentication functions
        const handleAuth = async (e) => {
          e.preventDefault();
          if (!window.firebaseAuthMethods) {
            pushAlert("Firebase not loaded - check configuration", "error");
            return;
          }

          try {
            if (authMode === 'register') {
              if (authForm.password !== authForm.confirmPassword) {
                pushAlert("Passwords don't match", "error");
                return;
              }
              await window.firebaseAuthMethods.createUserWithEmailAndPassword(
                window.firebaseAuth, authForm.email, authForm.password
              );
              pushAlert("Account created successfully!");
            } else {
              await window.firebaseAuthMethods.signInWithEmailAndPassword(
                window.firebaseAuth, authForm.email, authForm.password
              );
              pushAlert("Signed in successfully!");
            }
            setShowAuth(false);
            setAuthForm({ email: '', password: '', confirmPassword: '' });
          } catch (error) {
            pushAlert(error.message, "error");
          }
        };

        const handleSignOut = async () => {
          try {
            await window.firebaseAuthMethods.signOut(window.firebaseAuth);
            pushAlert("Signed out successfully");
          } catch (error) {
            pushAlert("Sign out failed", "error");
          }
        };

        // Migrations
        useEffect(()=>{ if (!skill.upgrades) setSkill({ points: skill.points||0, upgrades: {} }); }, []);

        // Alerts
        function pushAlert(message, kind="info") {
          const id = uid();
          setAlerts(a => [...a, { id, message, kind }]);
          setTimeout(()=> setAlerts(a => a.filter(x=>x.id!==id)), 4000);
        }

        // Daily rollover
        useEffect(()=>{
          const t = todayISO();
          if (dateInfo.lastOpen !== t) {
            setTasks(prev => prev.map(task => {
              const wasYesterday = task.lastCompleted === yestISO();
              const brokeStreak = task.lastCompleted && !wasYesterday;
              return { ...task, timesCompletedToday: 0, streak: brokeStreak ? 0 : (task.streak||0) };
            }));
            setDateInfo({ lastOpen: t });
          }
        }, []);

        // Levels (optimized with useMemo)
        const level = useMemo(()=> levelFromTotalXp(xp), [xp]);
        const currentLevelFloor = useMemo(()=> totalXpForLevel(level), [level]);
        const nextLevelFloor = useMemo(()=> totalXpForLevel(level+1), [level]);
        const progress = useMemo(()=> Math.min(1, (xp - currentLevelFloor) / (nextLevelFloor - currentLevelFloor)), [xp, currentLevelFloor, nextLevelFloor]);

        // Skill mods (optimized with useMemo)
        const skillMods = useMemo(() => {
          const U = skill.upgrades || {};
          const focusL = U.focus || 0;
          const momentumL = U.momentum || 0;
          const scholarL = U.scholar || 0;
          const efficiencyL = U.efficiency || 0;
          return {
            tasksMult: 1 + Math.min(focusL * 0.02, 0.50),
            passiveMult: 1 + Math.min(focusL * 0.01, 0.20),
            projectMult: 1 + Math.min(scholarL * 0.03, 0.60),
            baseFlat: Math.min(efficiencyL * 1, 10),
            streakCap: 2 + Math.min(momentumL * 0.05, 0.5)
          };
        }, [skill.upgrades]);
        
        const { tasksMult, passiveMult, projectMult, baseFlat, streakCap } = skillMods;

        // Level-up handling (SP + milestones)
        useEffect(()=>{
          if (level > lastLevel) {
            let baseSP = 0; for (let L=lastLevel+1; L<=level; L++) baseSP += skillPointsForLevel(L);
            if (baseSP>0) setSkill(s=>({...s, points:(s.points||0)+baseSP}));
            const newly = MILESTONES.filter(m=> m.level>lastLevel && m.level<=level && !(milestones.claimed||[]).includes(m.level));
            if (newly.length) {
              const bonus = newly.reduce((sum,m)=> sum+(m.sp||0), 0);
              if (bonus) setSkill(s=>({...s, points:(s.points||0)+bonus}));
              setMilestones(p=>({ claimed: [...(p.claimed||[]), ...newly.map(m=>m.level)] }));
              newly.forEach(m=> pushAlert(`Milestone: Level ${m.level} — +${m.sp} SP • ${m.badge}`));
            }
            setLastLevel(level);
          } else if (level < lastLevel) setLastLevel(level);
        }, [level]);

        // ---------- Logs derived ----------
        const todayStr = todayISO();
        const todayLogs = useMemo(()=> log.filter(e=> e.date === todayStr), [log, todayStr]);
        const sumBy = (arr, pred) => arr.filter(pred).reduce((s,e)=> s + (e.amount||0), 0);

        // Passive minutes (for efficiency throughput denominator)
        const todayPassiveMinutes = useMemo(()=> {
          return todayLogs.filter(e=> e.type === "passive").reduce((s,e)=> s + (e.meta?.minutes || 0), 0);
        }, [todayLogs]);

        const todayPassiveByCat = useMemo(()=> ({
          Study: sumBy(todayLogs, e=> e.type==="passive" && e.meta?.category==="Study"),
          Language: sumBy(todayLogs, e=> e.type==="passive" && e.meta?.category==="Language"),
          Training: sumBy(todayLogs, e=> e.type==="passive" && e.meta?.category==="Training"),
        }), [todayLogs]);

        const todayPassiveTotal = Object.values(todayPassiveByCat).reduce((a,b)=>a+b,0);
        const todayActiveTotal = sumBy(todayLogs, e=> e.type==="task" || e.type==="project");
        const todayTotal = todayPassiveTotal + todayActiveTotal;
        const passiveRatio = todayTotal>0 ? todayPassiveTotal/todayTotal : 0;

        // Last 7 days health metrics (optimized with useMemo)
        const lastNDates = (n) => {
          const dates=[]; const d=new Date();
          for (let i=0; i<n; i++){ const di=new Date(d); di.setDate(di.getDate()-i); dates.push(di.toISOString().slice(0,10)); }
          return dates.reverse();
        };
        
        const weekMetrics = useMemo(() => {
          const weekDays = lastNDates(7);
          const logsByDate = (d) => log.filter(e=> e.date===d);
          const weekProjectSteps = weekDays.reduce((s,d)=> s + logsByDate(d).filter(e=> e.type==="project_step").length, 0);
          const weekPassive = weekDays.reduce((s,d)=> s + sumBy(logsByDate(d), e=> e.type==="passive"), 0);
          const weekActive = weekDays.reduce((s,d)=> s + sumBy(logsByDate(d), e=> e.type==="task" || e.type==="project"), 0);
          const weekTotal = weekPassive + weekActive;
          const weekPassiveRatio = weekTotal>0 ? weekPassive/weekTotal : 0;
          const weekTasksCount = weekDays.reduce((s,d)=> s + logsByDate(d).filter(e=> e.type==="task").length, 0);
          const weekSPSpent = weekDays.reduce((s,d)=> s + sumBy(logsByDate(d), e=> e.type==="sp_spend"), 0);
          return { weekProjectSteps, weekPassive, weekActive, weekTotal, weekPassiveRatio, weekTasksCount, weekSPSpent };
        }, [log]);
        
        const { weekProjectSteps, weekPassive, weekActive, weekTotal, weekPassiveRatio, weekTasksCount, weekSPSpent } = weekMetrics;

        // Productivity insights (optimized with useMemo)
        const productivityInsights = useMemo(() => {
          const taskLogs = log.filter(e => e.type === "task");
          const focusLogs = log.filter(e => e.type === "passive");
          const projectLogs = log.filter(e => e.type === "project");
          
          // Best times to work (hourly analysis)
          const hourlyStats = {};
          taskLogs.forEach(log => {
            const hour = new Date(log.ts).getHours();
            if (!hourlyStats[hour]) hourlyStats[hour] = { count: 0, totalXP: 0 };
            hourlyStats[hour].count++;
            hourlyStats[hour].totalXP += log.amount || 0;
          });
          
          const bestHours = Object.entries(hourlyStats)
            .map(([hour, stats]) => ({ hour: parseInt(hour), ...stats, avgXP: stats.totalXP / stats.count }))
            .sort((a, b) => b.avgXP - a.avgXP)
            .slice(0, 3);
          
          // Task completion patterns
          const categoryStats = {};
          taskLogs.forEach(log => {
            const cat = log.meta?.category || "General";
            if (!categoryStats[cat]) categoryStats[cat] = { count: 0, totalXP: 0, avgTime: 0 };
            categoryStats[cat].count++;
            categoryStats[cat].totalXP += log.amount || 0;
            if (log.meta?.actualMin) {
              categoryStats[cat].avgTime = (categoryStats[cat].avgTime * (categoryStats[cat].count - 1) + log.meta.actualMin) / categoryStats[cat].count;
            }
          });
          
          const topCategories = Object.entries(categoryStats)
            .map(([cat, stats]) => ({ category: cat, ...stats, avgXP: stats.totalXP / stats.count }))
            .sort((a, b) => b.avgXP - a.avgXP)
            .slice(0, 3);
          
          // Daily patterns
          const dailyStats = {};
          const last30Days = lastNDates(30);
          last30Days.forEach(date => {
            const dayLogs = log.filter(e => e.date === date);
            const dayOfWeek = new Date(date).getDay();
            if (!dailyStats[dayOfWeek]) dailyStats[dayOfWeek] = { count: 0, totalXP: 0 };
            dailyStats[dayOfWeek].count += dayLogs.filter(e => e.type === "task").length;
            dailyStats[dayOfWeek].totalXP += sumBy(dayLogs, e => e.type === "task" || e.type === "project");
          });
          
          const bestDays = Object.entries(dailyStats)
            .map(([day, stats]) => ({ 
              day: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][parseInt(day)], 
              ...stats, 
              avgXP: stats.totalXP / Math.max(stats.count, 1) 
            }))
            .sort((a, b) => b.avgXP - a.avgXP)
            .slice(0, 3);
          
          return { bestHours, topCategories, bestDays };
        }, [log]);
        
        // Achievement calculations (optimized with useMemo)
        const achievementData = useMemo(() => {
          const taskLogs = log.filter(e => e.type === "task");
          const focusLogs = log.filter(e => e.type === "passive");
          const projectLogs = log.filter(e => e.type === "project");
          
          // Calculate achievement metrics
          const tasksCompleted = taskLogs.length;
          const projectsCompleted = projectLogs.length;
          const totalFocusHours = focusLogs.reduce((sum, log) => sum + (log.meta?.minutes || 0) / 60, 0);
          
          // Max streak calculation
          let maxStreak = 0;
          let currentStreak = 0;
          const last30Days = lastNDates(30);
          last30Days.forEach(date => {
            const hasTask = taskLogs.some(log => log.date === date);
            if (hasTask) {
              currentStreak++;
              maxStreak = Math.max(maxStreak, currentStreak);
            } else {
              currentStreak = 0;
            }
          });
          
          // Time-based achievements
          const earlyTasks = taskLogs.filter(log => new Date(log.ts).getHours() < 9).length;
          const nightTasks = taskLogs.filter(log => new Date(log.ts).getHours() >= 22).length;
          const efficientTasks = taskLogs.filter(log => {
            const actual = log.meta?.actualMin;
            const estimate = log.meta?.estimateMin;
            return actual && estimate && actual <= estimate;
          }).length;
          
          // Daily XP tracking
          const dailyXP = {};
          log.forEach(log => {
            if (log.type === "task" || log.type === "project") {
              dailyXP[log.date] = (dailyXP[log.date] || 0) + (log.amount || 0);
            }
          });
          const maxDailyXP = Math.max(...Object.values(dailyXP), 0);
          
          // Consecutive days
          let consecutiveDays = 0;
          const sortedDates = Object.keys(dailyXP).sort();
          for (let i = sortedDates.length - 1; i >= 0; i--) {
            const currentDate = new Date(sortedDates[i]);
            const prevDate = i > 0 ? new Date(sortedDates[i-1]) : null;
            if (prevDate && (currentDate - prevDate) / (1000 * 60 * 60 * 24) === 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }
          
          return {
            tasksCompleted,
            projectsCompleted,
            totalFocusHours,
            maxStreak,
            earlyTasks,
            nightTasks,
            efficientTasks,
            maxDailyXP,
            consecutiveDays
          };
        }, [log]);
        
        // Check and unlock achievements
        useEffect(() => {
          const unlocked = achievements.unlocked || [];
          const newAchievements = ACHIEVEMENTS.filter(achievement => 
            !unlocked.includes(achievement.id) && achievement.condition(achievementData)
          );
          
          if (newAchievements.length > 0) {
            setAchievements(prev => ({ 
              unlocked: [...(prev.unlocked || []), ...newAchievements.map(a => a.id)] 
            }));
            newAchievements.forEach(achievement => {
              pushAlert(`Achievement Unlocked: ${achievement.icon} ${achievement.name} - ${achievement.desc}`);
            });
          }
        }, [achievementData, achievements.unlocked]);

        // Challenge data calculation
        const challengeData = useMemo(() => {
          const todayLogs = log.filter(e => e.date === todayISO());
          const weekDays = lastNDates(7);
          const weekLogs = log.filter(e => weekDays.includes(e.date));
          
          return {
            tasksCompletedToday: todayLogs.filter(e => e.type === "task").length,
            focusSessionsToday: todayLogs.filter(e => e.type === "passive").length,
            earlyTasksToday: todayLogs.filter(e => e.type === "task" && new Date(e.ts).getHours() < 9).length,
            tasksCompletedThisWeek: weekLogs.filter(e => e.type === "task").length,
            projectsCompletedThisWeek: weekLogs.filter(e => e.type === "project").length,
            spSpentThisWeek: weekLogs.filter(e => e.type === "sp_spend").reduce((sum, e) => sum + (e.amount || 0), 0),
            ...achievementData
          };
        }, [log, todayISO(), lastNDates, achievementData]);
        
        // ML Analysis Functions
        const analyzeMLPatterns = () => {
          const taskHistory = log.filter(entry => entry.type === 'task' && entry.meta);
          const patterns = ML_SYSTEM.analyzePatterns(taskHistory);
          const learning = ML_SYSTEM.learnFromAdjustments(xpLearning.userAdjustments, patterns);
          const insights = ML_SYSTEM.generateInsights(patterns, learning, taskHistory);
          
          setMlData({
            patterns,
            learning,
            insights,
            lastAnalysis: Date.now()
          });
        };

        // Enhanced ML-Enhanced XP Calculation Functions
        const suggestXP = (title, subject, subSkill, taskType, difficulty, estimatedTime, userLevel = 5) => {
          // Get dual-track XP calculation
          const dualTrackResult = calculateDualTrackXP(subject, subSkill, taskType, difficulty, estimatedTime, userLevel);
          
          // Return the total XP for backward compatibility with UI
          return dualTrackResult.xp;
        };

        const getMLRecommendation = (subject, subSkill, taskType, difficulty, estimatedTime, userLevel = 5) => {
          const prediction = ML_SYSTEM.predictOptimalXP(
            subject, subSkill, taskType, difficulty, estimatedTime, 
            mlData.patterns, mlData.learning, userLevel
          );
          
          return {
            xp: prediction.xp,
            confidence: Math.round(prediction.confidence * 100),
            breakdown: prediction.breakdown,
            objective: ML_SYSTEM.calculateObjectiveXP(subject, subSkill, taskType, difficulty, estimatedTime, userLevel)
          };
        };

        // Enhanced Dual-Track Auto-XP calculation
        const calculateDualTrackXP = (subject, subSkill, taskType, difficulty, estimatedTime, userLevel = 5) => {
          // Get objective XP based on academic knowledge
          const objectiveXP = ML_SYSTEM.calculateObjectiveXP(subject, subSkill, taskType, difficulty, estimatedTime, userLevel);
          
          // ML prediction if available
          let mlPrediction = null;
          if (Object.keys(xpLearning.userAdjustments).length > 3) {
            mlPrediction = ML_SYSTEM.predictOptimalXP(
              subject, subSkill, taskType, difficulty, estimatedTime, 
              mlData.patterns, mlData.learning, userLevel
            );
          }
          
          // Use ML prediction or objective calculation
          const finalXP = mlPrediction ? mlPrediction.xp : objectiveXP;
          
          // Calculate dual-track distribution
          const distribution = calculateDualTrackDistribution(finalXP, userLevel, {
            subject, subSkill, taskType, difficulty, estimatedTime
          });
          
          return {
            // Backward compatibility
            xp: finalXP,
            confidence: mlPrediction ? mlPrediction.confidence : 0.8,
            source: mlPrediction ? 'ML Enhanced' : 'Academic Knowledge',
            
            // Enhanced dual-track breakdown
            dualTrack: {
              mastery: distribution.mastery,
              momentum: distribution.momentum,
              coins: distribution.coins
            },
            
            breakdown: mlPrediction ? mlPrediction.breakdown : {
              objective: objectiveXP,
              categoryBias: 1.0,
              difficultyBias: 1.0,
              timeAdjustment: 1.0,
              confidence: 0.8
            }
          };
        };

        // Dual-Track Distribution Calculation
        const calculateDualTrackDistribution = (baseXP, userLevel, taskAnalysis) => {
          // Get distribution weights based on user level
          const getDistributionWeights = (level) => {
            if (level <= 20) return DUAL_TRACK_CONFIG.distribution.early;
            if (level <= 60) return DUAL_TRACK_CONFIG.distribution.mid;
            return DUAL_TRACK_CONFIG.distribution.late;
          };
          
          const weights = getDistributionWeights(userLevel);
          
          // Calculate XP distribution
          const masteryXP = Math.round(baseXP * weights.mastery);
          const momentumXP = Math.round(baseXP * weights.momentum);
          const coins = Math.round(baseXP * weights.coins);
          
          // Add bonuses and adjustments
          const bonuses = calculateDualTrackBonuses(taskAnalysis, userLevel);
          
          return {
            mastery: {
              xp: masteryXP + bonuses.masteryBonus,
              evidence: generateEvidenceRequirements(taskAnalysis),
              subskill: taskAnalysis.subSkill,
              unlock: checkUnlockRequirements(taskAnalysis)
            },
            momentum: {
              xp: momentumXP + bonuses.momentumBonus,
              coins: coins + bonuses.coinBonus,
              level: calculateLevelProgress(momentumXP + bonuses.momentumBonus),
              banking: addToUnbankedXP(momentumXP + bonuses.momentumBonus)
            }
          };
        };

        // Calculate dual-track bonuses
        const calculateDualTrackBonuses = (taskAnalysis, userLevel) => {
          const bonuses = {
            masteryBonus: 0,
            momentumBonus: 0,
            coinBonus: 0
          };
          
          // Quality bonuses (from reflection quality)
          if (taskAnalysis.quality === 'excellent') {
            bonuses.masteryBonus += 5;
            bonuses.coinBonus += DUAL_TRACK_CONFIG.coinEconomy.earning.quality_bonus;
          }
          
          // Focus bonuses
          if (taskAnalysis.focus === 'deep_work') {
            bonuses.momentumBonus += 3;
            bonuses.coinBonus += DUAL_TRACK_CONFIG.coinEconomy.earning.focus_bonus;
          }
          
          // Novelty bonuses (first time tackling subskill)
          if (taskAnalysis.novelty) {
            bonuses.masteryBonus += 8;
            bonuses.coinBonus += DUAL_TRACK_CONFIG.coinEconomy.earning.novelty_bonus;
          }
          
          // Streak bonuses
          if (dualTrackData.progression.streak > 0) {
            bonuses.coinBonus += DUAL_TRACK_CONFIG.coinEconomy.earning.streak_bonus;
          }
          
          return bonuses;
        };

        // Generate evidence requirements for mastery tracking
        const generateEvidenceRequirements = (taskAnalysis) => {
          return {
            type: taskAnalysis.taskType,
            subject: taskAnalysis.subject,
            subskill: taskAnalysis.subSkill,
            difficulty: taskAnalysis.difficulty,
            estimatedTime: taskAnalysis.estimatedTime,
            timestamp: Date.now(),
            requirements: {
              accuracy: taskAnalysis.difficulty === 'expert' ? 90 : 80,
              timeBonus: taskAnalysis.estimatedTime < 30,
              quality: 'good'
            }
          };
        };

        // Check unlock requirements
        const checkUnlockRequirements = (taskAnalysis) => {
          const subject = taskAnalysis.subject.toLowerCase();
          const unlocks = DUAL_TRACK_CONFIG.mastery.unlockRequirements;
          
          const availableUnlocks = [];
          Object.entries(unlocks).forEach(([unlockName, unlockData]) => {
            if (unlockData.subject === subject) {
              availableUnlocks.push({
                name: unlockName,
                cost: unlockData.cost,
                requirements: unlockData.requirements
              });
            }
          });
          
          return availableUnlocks;
        };

        // Calculate level progress
        const calculateLevelProgress = (momentumXP) => {
          const currentLevel = dualTrackData.momentum.level;
          const currentXP = dualTrackData.momentum.xp;
          const xpToNext = dualTrackData.momentum.xpToNext;
          
          const newXP = currentXP + momentumXP;
          const newLevel = Math.floor(newXP / xpToNext) + currentLevel;
          const newXPToNext = calculateXPToNext(newLevel);
          
          return {
            currentLevel: currentLevel,
            newLevel: newLevel,
            currentXP: currentXP,
            newXP: newXP,
            xpToNext: xpToNext,
            newXPToNext: newXPToNext,
            levelUp: newLevel > currentLevel
          };
        };

        // Calculate XP required for next level
        const calculateXPToNext = (level) => {
          if (level <= 20) return DUAL_TRACK_CONFIG.levelScaling.early.baseXP;
          if (level <= 60) return DUAL_TRACK_CONFIG.levelScaling.mid.baseXP;
          return DUAL_TRACK_CONFIG.levelScaling.late.baseXP;
        };

        // Add XP to unbanked pool
        const addToUnbankedXP = (momentumXP) => {
          const currentUnbanked = dualTrackData.momentum.unbankedXP || 0;
          return currentUnbanked + momentumXP;
        };

        // Banking System with ML Insights
        const bankingSystem = {
          // Daily review with ML-generated prompts
          campAction: {
            generatePrompts: () => {
              const basePrompts = [
                "What was your most challenging task today?",
                "Which subskill did you improve most?",
                "What will you focus on tomorrow?",
                "Rate your focus quality (1-5)"
              ];
              
              // ML-enhanced prompts based on user patterns
              if (mlData.patterns && Object.keys(mlData.patterns).length > 0) {
                const mlPrompts = ML_SYSTEM.generatePersonalizedPrompts(mlData.patterns);
                return [...basePrompts, ...mlPrompts];
              }
              
              return basePrompts;
            },
            
            assessReflectionQuality: (userInput) => {
              // Simple quality assessment based on input length and keywords
              const quality = {
                score: 0,
                factors: []
              };
              
              // Length factor
              if (userInput.length > 100) {
                quality.score += 2;
                quality.factors.push("detailed reflection");
              } else if (userInput.length > 50) {
                quality.score += 1;
                quality.factors.push("moderate reflection");
              }
              
              // Keyword analysis
              const keywords = ['challenging', 'improved', 'learned', 'difficult', 'progress', 'understanding'];
              const foundKeywords = keywords.filter(keyword => 
                userInput.toLowerCase().includes(keyword)
              );
              
              quality.score += foundKeywords.length;
              quality.factors.push(`${foundKeywords.length} reflection keywords`);
              
              return {
                score: Math.min(5, quality.score),
                factors: quality.factors,
                multiplier: quality.score >= 4 ? 1.5 : quality.score >= 3 ? 1.2 : 1.0
              };
            },
            
            processBanking: (userInput) => {
              const quality = bankingSystem.campAction.assessReflectionQuality(userInput);
              const unbankedXP = dualTrackData.momentum.unbankedXP || 0;
              const currentCoins = dualTrackData.momentum.coins || 0;
              
              // Calculate rewards
              const baseCoins = DUAL_TRACK_CONFIG.banking.rewards.baseCoins;
              const qualityBonus = Math.round(baseCoins * (quality.multiplier - 1));
              const streakBonus = dualTrackData.momentum.streak * DUAL_TRACK_CONFIG.banking.rewards.streakBonus;
              const totalCoins = baseCoins + qualityBonus + streakBonus;
              
              // Update dual-track data
              setDualTrackData(prev => ({
                ...prev,
                momentum: {
                  ...prev.momentum,
                  xp: prev.momentum.xp + unbankedXP,
                  unbankedXP: 0,
                  coins: prev.momentum.coins + totalCoins,
                  lastBankTime: Date.now(),
                  streak: prev.momentum.streak + 1
                },
                progression: {
                  ...prev.progression,
                  dailyTasksCompleted: 0,
                  lastLevelUp: prev.momentum.level !== prev.momentum.level ? Date.now() : prev.progression.lastLevelUp
                }
              }));
              
              // Check for level up
              const levelProgress = calculateLevelProgress(0);
              if (levelProgress.levelUp) {
                handleLevelUp(levelProgress.newLevel);
              }
              
              return {
                success: true,
                bankedXP: unbankedXP,
                earnedCoins: totalCoins,
                quality: quality,
                levelUp: levelProgress.levelUp,
                newLevel: levelProgress.newLevel
              };
            }
          },
          
          // Risk system
          risk: {
            checkRisk: () => {
              const lastBankTime = dualTrackData.momentum.lastBankTime;
              const now = Date.now();
              const daysSinceLastBank = lastBankTime ? (now - lastBankTime) / (1000 * 60 * 60 * 24) : 0;
              
              if (daysSinceLastBank >= DUAL_TRACK_CONFIG.banking.risk.missBankingDays) {
                const unbankedXP = dualTrackData.momentum.unbankedXP || 0;
                const lossAmount = Math.round(unbankedXP * DUAL_TRACK_CONFIG.banking.risk.lossRate);
                
                setDualTrackData(prev => ({
                  ...prev,
                  momentum: {
                    ...prev.momentum,
                    unbankedXP: Math.max(0, prev.momentum.unbankedXP - lossAmount),
                    streak: 0 // Reset streak on missed banking
                  }
                }));
                
                return {
                  riskTriggered: true,
                  daysMissed: Math.floor(daysSinceLastBank),
                  lossAmount: lossAmount,
                  remainingXP: Math.max(0, unbankedXP - lossAmount)
                };
              }
              
              return { riskTriggered: false };
            }
          }
        };

        // Level up handler
        const handleLevelUp = (newLevel) => {
          const rewards = {
            coins: Math.round(newLevel * 5), // 5 coins per level
            points: 1, // 1 skill point per level
            unlocks: getLevelUnlocks(newLevel)
          };
          
          setDualTrackData(prev => ({
            ...prev,
            momentum: {
              ...prev.momentum,
              coins: prev.momentum.coins + rewards.coins
            },
            progression: {
              ...prev.progression,
              lastLevelUp: Date.now(),
              masteryMilestones: [...prev.progression.masteryMilestones, {
                type: 'level_up',
                level: newLevel,
                timestamp: Date.now(),
                rewards: rewards
              }]
            }
          }));
          
          pushAlert(`Level Up! You're now level ${newLevel}! Earned ${rewards.coins} coins and 1 skill point.`);
        };

        // Get unlocks for specific level
        const getLevelUnlocks = (level) => {
          const unlocks = [];
          
          if (level === 5) unlocks.push("Scholar Robe Theme");
          if (level === 10) unlocks.push("Master's Cap Theme");
          if (level === 15) unlocks.push("Expert Badge Theme");
          if (level === 20) unlocks.push("Advanced Skill Tree Access");
          if (level === 30) unlocks.push("Prestige Mode Unlocked");
          
          return unlocks;
        };

        // Backward compatibility - keep original function
        const calculateAutoXP = calculateDualTrackXP;

        const learnFromUserAdjustment = (category, taskType, difficulty, suggestedXP, actualXP) => {
          if (suggestedXP === actualXP) return; // No learning needed
          
          const learningKey = `${category}-${taskType}-${difficulty}`;
          const adjustment = actualXP / suggestedXP;
          
          setXpLearning(prev => ({
            ...prev,
            userAdjustments: {
              ...prev.userAdjustments,
              [learningKey]: adjustment
            }
          }));
        };

        const getTaskTypeSuggestions = (category) => {
          const categoryMatrix = XP_MATRIX[category] || XP_MATRIX['General'];
          return Object.keys(categoryMatrix);
        };

        const getDifficultySuggestions = () => {
          return Object.keys(DIFFICULTY_MULTIPLIERS);
        };

        function logEntry(entry){
          setLog(L => [{ id: uid(), ts: nowTs(), date: todayISO(), ...entry }, ...L]);
        }

        // ---------- Settings: Passive Caps (static/dynamic) ----------
        function dynamicCaps() {
          // Scale with last 7 days *active* XP
          const last7 = lastNDates(7);
          const active7 = last7.reduce((s,d)=> s + sumBy(log.filter(e=> e.date===d), e=> e.type==="task" || e.type==="project"), 0);
          const avgActivePerDay = active7 / 7;
          // Base 160 + 0.6×avgActive; clamp 120..400
          const total = Math.max(120, Math.min(400, Math.round(160 + 0.6 * avgActivePerDay)));
          const perCat = Math.round(total * 0.5);
          return { total, perCat };
        }
        const caps = settings.capMode === "dynamic"
          ? dynamicCaps()
          : { total: settings.staticTotal, perCat: settings.staticPerCat };

        // ================== Task creation & completion ==================
        const [form, setForm] = useState({ 
          title:"", 
          subject:"math", 
          mainSkill:"pre_calculus",
          subSkill:"arithmetic_foundations",
          difficulty:"Medium", 
          baseXP: 10, 
          estimateMin: 30,
          suggestedXP: 10,
          showAdvanced: false
        });

        // Auto-suggest XP when form changes
        useEffect(() => {
          if (form.subSkill) {
            const subSkill = findSubSkillById(form.subSkill);
            if (subSkill) {
              setForm(prev => ({ 
                ...prev, 
                baseXP: subSkill.baseXP,
                suggestedXP: subSkill.baseXP 
              }));
            }
          }
        }, [form.subSkill]);

        // Trigger ML analysis when log changes significantly
        useEffect(() => {
          if (log.length > 0 && log.length % 10 === 0) { // Analyze every 10 tasks
            analyzeMLPatterns();
          }
        }, [log.length]);

        // Check banking risk on app load
        useEffect(() => {
          const riskCheck = bankingSystem.risk.checkRisk();
          if (riskCheck.riskTriggered) {
            pushAlert(`Warning: You missed banking for ${riskCheck.daysMissed} days. Lost ${riskCheck.lossAmount} XP.`, "error");
          }
        }, []);

        function addTask(e){
          e.preventDefault();
          const title = form.title.trim(); if (!title) return;
          
          // Enhanced dual-track XP calculation
          let taskXP;
          if (settings.autoXPMode) {
            const dualTrackXP = calculateDualTrackXP(form.subject, form.subSkill, 'Practice', form.difficulty, form.estimateMin, settings.userLevel);
            taskXP = dualTrackXP;
            pushAlert(`Dual-Track XP calculated: ${dualTrackXP.xp} XP (${dualTrackXP.source})`);
          } else {
            const manualXP = Math.max(1, Number(form.baseXP)||10);
            // Convert manual XP to dual-track format for consistency
            taskXP = {
              xp: manualXP,
              source: 'Manual Input',
              dualTrack: {
                mastery: { xp: manualXP * 0.6 },
                momentum: { xp: manualXP * 0.3, coins: manualXP * 0.1 }
              }
            };
          }
          
          const estimateMin = Math.max(0, Number(form.estimateMin)||0);
          
          // Get sub-skill information
          const subSkill = findSubSkillById(form.subSkill);
          if (!subSkill) {
            pushAlert("Please select a valid sub-skill", "error");
            return;
          }

          // Create task with dual-track data
          const newTask = {
            id: uid(), 
            title, 
            subject: form.subject,
            mainSkill: form.mainSkill,
            subSkillId: form.subSkill,
            subSkillName: subSkill.name,
            difficulty: form.difficulty,
            baseXP: taskXP.xp, // Total XP for backward compatibility
            estimateMin, 
            createdAt: todayISO(),
            streak: 0, 
            lastCompleted: null, 
            timesCompletedToday: 0,
            // Enhanced dual-track data
            dualTrack: taskXP.dualTrack,
            source: taskXP.source,
            confidence: taskXP.confidence || 1.0
          };
          
          setTasks(t => [...t, newTask]);
          
          // Update dual-track progression data
          setDualTrackData(prev => ({
            ...prev,
            progression: {
              ...prev.progression,
              totalTasksCreated: (prev.progression.totalTasksCreated || 0) + 1
            }
          }));
          setForm(f => ({ 
            ...f, 
            title:"" 
          }));
        }

        // Efficiency helpers from logs
        function categoryMedianMinutes(cat){
          const cutoffTs = nowTs() - 14*86400000;
          const mins = log.filter(e => e.type==="task" && e.meta?.category===cat && e.meta?.actualMin && e.ts >= cutoffTs)
                          .map(e => e.meta.actualMin);
          return median(mins) || null;
        }
        function contextRunCount(cat){
          const cutoffTs = nowTs() - 90*60000; // last 90 minutes
          return 1 + log.filter(e => e.type==="task" && e.meta?.category===cat && e.ts >= cutoffTs).length;
        }
        function todaysTaskXPTotal(){
          return sumBy(todayLogs, e=> e.type==="task");
        }
        function todaysEfficiencyBonusPaid(){
          return sumBy(todayLogs, e=> e.type==="efficiency_daily");
        }

        function completeTask(taskId){
          const now = nowTs();
          const today = todayISO();

          setTasks(prev => prev.map(t => {
            if (t.id !== taskId) return t;
            if (t.timesCompletedToday >= 1) return t;

            // Ask optional actual minutes (for efficiency calc). Cancel/blank means skip minutes.
            let actualMin = null;
            const ans = prompt("Minutes spent on this task? (optional number)", t.estimateMin ? String(t.estimateMin) : "");
            if (ans !== null && ans.trim() !== "" && !isNaN(Number(ans))) actualMin = Math.max(0, Math.round(Number(ans)));

            // NEW: Get sub-skill information
            const subSkillId = t.subSkillId;
            const subject = t.subject;
            
            if (!subSkillId || !subject) {
              pushAlert("Task missing sub-skill information. Please recreate the task.", "error");
              return t;
            }

            // Get sub-skill progress
            const currentSubSkillXP = subSkillProgress[subSkillId]?.xp || 0;
            const subSkill = findSubSkillById(subSkillId);
            
            if (!subSkill) {
              pushAlert("Sub-skill not found. Please recreate the task.", "error");
              return t;
            }

            // Calculate XP using new system
            const baseXP = t.baseXP || subSkill.baseXP || 10;
            const taskXP = calculateTaskXP(
              { xp: currentSubSkillXP }, 
              baseXP, 
              t.estimateMin, 
              actualMin, 
              t.difficulty
            );

            // Apply skill bonuses
            const continued = t.lastCompleted === yestISO();
            const newStreak = continued ? (t.streak||0)+1 : 1;
            const streakMult = Math.min(1 + 0.1*(newStreak-1), streakCap);
            const novelty = t.lastCompleted ? 0 : Math.round(taskXP*0.2);
            let finalXP = Math.round((Math.round(taskXP*streakMult) + novelty) * tasksMult);

            // Update sub-skill progress
            setSubSkillProgress(prev => ({
              ...prev,
              [subSkillId]: {
                ...prev[subSkillId],
                xp: (prev[subSkillId]?.xp || 0) + finalXP,
                tasksCompleted: (prev[subSkillId]?.tasksCompleted || 0) + 1,
                lastCompleted: today
              }
            }));

            // Update subject XP
            setSubjectXP(prev => ({
              ...prev,
              [subject]: prev[subject] + finalXP
            }));

            // Update global XP
            setXp(x => x + finalXP);

            // Update dual-track system
            const dualTrackXP = t.dualTrack || {
              mastery: { xp: finalXP * 0.6 },
              momentum: { xp: finalXP * 0.3, coins: finalXP * 0.1 }
            };
            
            setDualTrackData(prev => ({
              ...prev,
              // Add momentum XP to unbanked pool
              momentum: {
                ...prev.momentum,
                unbankedXP: (prev.momentum.unbankedXP || 0) + Math.round(dualTrackXP.momentum.xp),
                coins: (prev.momentum.coins || 0) + Math.round(dualTrackXP.momentum.coins)
              },
              // Update mastery evidence
              mastery: {
                ...prev.mastery,
                evidence: [...(prev.mastery.evidence || []), {
                  taskId: t.id,
                  subject: subject,
                  subSkill: subSkillId,
                  xp: Math.round(dualTrackXP.mastery.xp),
                  timestamp: Date.now(),
                  difficulty: t.difficulty,
                  quality: 'good', // Default quality
                  actualMin: actualMin,
                  efficiency: actualMin ? (t.estimateMin / actualMin) : null
                }]
              },
              // Update progression
              progression: {
                ...prev.progression,
                totalTasksCompleted: (prev.progression.totalTasksCompleted || 0) + 1,
                dailyTasksCompleted: (prev.progression.dailyTasksCompleted || 0) + 1
              }
            }));

            // Logs
            logEntry({ type:"task", amount: finalXP, meta: {
              taskId: t.id, title: t.title, subject: subject, subSkillId: subSkillId,
              subSkillName: subSkill.name, estimateMin: t.estimateMin||null, 
              actualMin: actualMin, baseXP: baseXP, difficulty: t.difficulty,
              dualTrack: dualTrackXP // Enhanced logging
            }});

            pushAlert(`Task: +${finalXP} XP • ${subSkill.name} • ${t.title} • +${Math.round(dualTrackXP.momentum.coins)} coins`);

            // Update task fields
            return { ...t, lastCompleted: today, streak: newStreak, timesCompletedToday: 1 };
          }));

          // Recompute daily throughput tier (based on task XP vs focused minutes)
          setTimeout(()=> recomputeDailyThroughputBonus(), 0);
        }

        // Helper function to find sub-skill by ID
        function findSubSkillById(targetSubSkillId) {
          for (const subjectId in SKILL_TREES) {
            const subject = SKILL_TREES[subjectId];
            for (const mainSkillId in subject.mainSkills) {
              const mainSkill = subject.mainSkills[mainSkillId];
              for (const subSkillId in mainSkill.subSkills) {
                const subSkill = mainSkill.subSkills[subSkillId];
                if (subSkill.id === targetSubSkillId) {
                  return subSkill;
                }
              }
            }
          }
          return null;
        }

        function deleteTask(taskId){
          setTasks(tasks.filter(t=> t.id!==taskId));
        }

        // Daily throughput bonus (10%/20% of today's task XP, cap +200/day)
        function recomputeDailyThroughputBonus(){
          const taskXP = todaysTaskXPTotal();
          const minutes = todayPassiveMinutes; // focused minutes from sessions
          if (minutes <= 0 || taskXP <= 0) return;

          const eff = taskXP / minutes;
          const tier = eff >= 1.5 ? 0.20 : (eff >= 1.2 ? 0.10 : 0);
          if (!tier) return;

          const target = Math.min(200, Math.round(tier * taskXP));
          const already = todaysEfficiencyBonusPaid();
          const delta = target - already;
          if (delta > 0) {
            setXp(x => x + delta);
            logEntry({ type:"efficiency_daily", amount: delta, meta: { eff, minutes, taskXP, tier } });
            pushAlert(`Daily throughput bonus: +${delta} XP`);
          }
        }

        // ================== Projects (with deadlines) ==================
        const [projForm, setProjForm] = useState({
          title:"", description:"", rewardXP: 1000, dueDate:"", committed: false,
          subject: "math", mainSkill: "pre_calculus", subSkill: "arithmetic_foundations"
        });

        function addProject(e){
          e.preventDefault();
          const title = projForm.title.trim(); if (!title) return;
          const rewardXP = Math.max(1, Number(projForm.rewardXP)||1000);
          
          // Get sub-skill information
          const subSkill = findSubSkillById(projForm.subSkill);
          if (!subSkill) {
            pushAlert("Please select a valid sub-skill", "error");
            return;
          }
          
          const p = {
            id: uid(),
            title,
            description: projForm.description.trim(),
            rewardXP,
            subject: projForm.subject,
            mainSkill: projForm.mainSkill,
            subSkillId: projForm.subSkill,
            subSkillName: subSkill.name,
            steps: [], // {id,title,done,doneAtDate?}
            completedAt: null,
            dueDate: projForm.dueDate || "",
            committed: !!projForm.committed
          };
          setProjects([p, ...projects]);
          setProjForm(f=> ({ ...f, title:"", description:"" }));
        }

        function deleteProject(projectId){
          setProjects(projects.filter(p=> p.id!==projectId));
        }

        function addProjectStep(projectId, stepTitle){
          const title = (stepTitle||"").trim(); if (!title) return;
          setProjects(prev => prev.map(p => p.id===projectId ? { ...p, steps:[...p.steps, { id: uid(), title, done:false }] } : p));
        }

        function toggleStep(projectId, stepId){
          const today = todayISO();
          setProjects(prev => {
            const updated = prev.map(p => {
              if (p.id !== projectId) return p;
              const steps = p.steps.map(s => s.id===stepId ? { ...s, done: !s.done, doneAtDate: !s.done ? today : null } : s);
              const allDone = steps.length>0 && steps.every(s=> s.done);
              const completedAt = allDone && !p.completedAt ? today : p.completedAt;
              return { ...p, steps, completedAt };
            });

            // Detect completion transition
            const before = prev.find(x=> x.id===projectId);
            const after  = updated.find(x=> x.id===projectId);
            if (!before?.completedAt && after?.completedAt) {
              onProjectCompleted(after);
            }
            return updated;
          });
        }

        function onProjectCompleted(p){
          const B = p.rewardXP || 0;
          let reward = Math.round(B * projectMult);
          const completedDate = p.completedAt; // YYYY-MM-DD
          const hasDue = !!p.dueDate;

          // Distribution gate: steps completed on ≥ min(3, ceil(total/3)) distinct days
          const doneDates = Array.from(new Set((p.steps||[]).filter(s=> s.done && s.doneAtDate).map(s=> s.doneAtDate)));
          const minDays = Math.min(3, Math.max(1, Math.ceil((p.steps||[]).length / 3)));
          const distributionOK = doneDates.length >= minDays;

          // Deadline bonus
          let deadlineBonus = 0;
          let deadlineFlag = "late";
          if (hasDue && distributionOK) {
            const comp = new Date(completedDate+"T00:00:00");
            const due = new Date(p.dueDate+"T00:00:00");
            const diffDays = Math.floor((due - comp)/86400000); // positive if early

            if (diffDays >= 1) {
              deadlineBonus = Math.round(Math.min(0.25*B, 0.04*B*diffDays));
              deadlineFlag = "early";
            } else if (Math.abs(Math.floor((comp - due)/86400000)) <= 1) {
              deadlineBonus = Math.round(0.10*B);
              deadlineFlag = "on_time";
            } else {
              deadlineBonus = 0;
              deadlineFlag = "late";
            }
          }

          // Weekly cap for deadline bonuses: 500 XP
          const weekKey = isoWeekKey(completedDate);
          const weekAlready = log.filter(e=> e.type==="deadline_bonus" && e.meta?.week===weekKey)
                                 .reduce((s,e)=> s + (e.amount||0), 0);
          const capRemain = Math.max(0, 500 - weekAlready);
          const appliedDeadlineBonus = Math.min(deadlineBonus, capRemain);

          // Apply rewards
          const totalGrant = reward + appliedDeadlineBonus;
          
          // NEW: Award XP to specific subject and sub-skill if project has skill information
          if (p.subject && p.subSkillId) {
            // Update sub-skill progress
            setSubSkillProgress(prev => ({
              ...prev,
              [p.subSkillId]: {
                ...prev[p.subSkillId],
                xp: (prev[p.subSkillId]?.xp || 0) + totalGrant,
                tasksCompleted: (prev[p.subSkillId]?.tasksCompleted || 0) + 1,
                lastCompleted: completedDate
              }
            }));

            // Update subject XP
            setSubjectXP(prev => ({
              ...prev,
              [p.subject]: (prev[p.subject] || 0) + totalGrant
            }));
            
            // Log project reward with skill information
            logEntry({ 
              type:"project", 
              amount: reward, 
              meta: { 
                projectId: p.id, 
                title: p.title, 
                subject: p.subject, 
                subSkillId: p.subSkillId,
                subSkillName: p.subSkillName 
              } 
            });
          } else {
            // Fallback to global XP only (for legacy projects without skill info)
            setXp(x => x + totalGrant);
            logEntry({ type:"project", amount: reward, meta: { projectId: p.id, title: p.title } });
          }
          
          // Global XP (always award to global total)
          setXp(x => x + totalGrant);
          
          if (appliedDeadlineBonus>0) {
            logEntry({ type:"deadline_bonus", amount: appliedDeadlineBonus, meta: { projectId: p.id, title: p.title, flag: deadlineFlag, week: weekKey } });
          }
          pushAlert(`Project complete: +${totalGrant} XP • ${p.subSkillName || 'General'} • ${p.title}${appliedDeadlineBonus?` (+${appliedDeadlineBonus} deadline bonus)`:''}`);

          // SP token for two+ on-time/early projects this week (max 2/week)
          if (appliedDeadlineBonus>0) {
            const metCount = log.filter(e=> e.type==="deadline_bonus" && e.meta?.week===weekKey).length + 1; // +1 for this just-logged
            const spGrantedThisWeek = log.filter(e=> e.type==="deadline_sp" && e.meta?.week===weekKey)
                                         .reduce((s,e)=> s + (e.amount||0), 0);
            if (metCount >= 2 && spGrantedThisWeek < 2) {
              setSkill(s=> ({ ...s, points: (s.points||0) + 1 }));
              logEntry({ type:"deadline_sp", amount: 1, meta: { week: weekKey } });
              pushAlert(`Bonus: +1 SP for consistent deadlines (week ${weekKey})`);
            }
          }
        }

        // ================== Focus Sessions (Passive XP) ==================
        const [focusUI, setFocusUI] = useState({ category:"Study", minutes:25, outcome:"" });
        const [tick, setTick] = useState(0);

        useEffect(()=>{ if (!session) return; const id=setInterval(()=>setTick(t=>t+1), 1000); return ()=>clearInterval(id); }, [session]);
        useEffect(()=>{ if (!session) return; if (tick>0 && tick%300===0) pushAlert("Still focused? Keep going ✨"); }, [tick, session]);

        function startSession(){
          if (session) return;
          const mins = Math.max(10, Number(focusUI.minutes)||25);
          setSession({ id: uid(), startedAt: nowTs(), category: focusUI.category, targetMinutes: mins, outcome: "" });
        }
        function stopSession(){ setSession(null); }

        // Passive claim with caps (static or dynamic)
        function claimSession(outcomeText){
          if (!session) return;
          const end = nowTs();
          const minutes = Math.floor(Math.max(0, end - session.startedAt) / 60000);
          if (!outcomeText || outcomeText.trim().length<4){ pushAlert("Add a short micro-outcome to claim XP"); return; }

          const rate = PASSIVE_RATES[session.category] || 1.0;
          const blocks = Math.floor(minutes/25);
          let xpBase = Math.round(minutes*rate + blocks*PASSIVE_BLOCK_BONUS);
          xpBase = Math.round(xpBase * passiveMult);

          // Caps with soft overflow at half-rate, using chosen caps
          const alreadyCat = todayPassiveByCat[session.category] || 0;
          const alreadyTotal = todayPassiveTotal;
          const TOTAL_CAP = caps.total;
          const CAT_CAP = caps.perCat;

          const remainingCat = Math.max(0, CAT_CAP - alreadyCat);
          const remainingTotal = Math.max(0, TOTAL_CAP - alreadyTotal);
          const regularCredit = Math.min(xpBase, remainingCat, remainingTotal);
          let credited = regularCredit;
          let halved = 0;

          if (xpBase > regularCredit){
            const overflow = xpBase - regularCredit;
            const halfCredit = Math.floor(overflow/2);
            const halfRoomCat = Math.max(0, CAT_CAP*2 - (alreadyCat + regularCredit));
            const halfRoomTotal = Math.max(0, TOTAL_CAP*2 - (alreadyTotal + regularCredit));
            halved = Math.min(halfCredit, halfRoomCat, halfRoomTotal);
            credited += halved;
          }

          if (credited <= 0){ pushAlert("Passive caps reached — no XP credited"); setSession(null); return; }

          setXp(x=> x + credited);
          logEntry({ type:"passive", amount: credited, meta: { category: session.category, minutes, outcome: outcomeText } });
          pushAlert(`Focus Session: +${credited} XP • ${session.category}`);
          setSession(null);
          setFocusUI(f=> ({ ...f, outcome:"" }));

          // Recompute daily throughput bonus after new minutes arrive
          setTimeout(()=> recomputeDailyThroughputBonus(), 0);
        }

        // ================== Skill Tree ==================
        function upgLevel(key){ return (skill.upgrades && skill.upgrades[key]) || 0; }
        function upgCost(key){ const lvl=upgLevel(key); const def=SKILL_TREE[key]; return def.cost(lvl); }
        function totalSpentFor(key,lvl){ const def=SKILL_TREE[key]; let sum=0; for(let i=0;i<lvl;i++) sum+=def.cost(i); return sum; }
        function buyUpgrade(key){
          const def=SKILL_TREE[key]; const lvl=upgLevel(key);
          if (lvl>=def.max) return; const cost=def.cost(lvl);
          if ((skill.points||0) < cost) return;
          setSkill(s=> ({ points:(s.points||0)-cost, upgrades:{ ...(s.upgrades||{}), [key]: lvl+1 } }));
          logEntry({ type:"sp_spend", amount: cost, meta:{ key } });
        }
        function respecAll(){
          if (!confirm("Respec skills and refund all SP?")) return;
          const up = skill.upgrades||{};
          const refund = Object.keys(up).reduce((acc,k)=> acc + totalSpentFor(k, up[k]||0), 0);
          setSkill({ points:(skill.points||0)+refund, upgrades:{} });
        }

        // ================== Export/Import/Reset ==================
        function exportData(){
          const snapshot = { tasks, projects, xp, skill, lastLevel, milestones, dateInfo, log, settings, theme, subjectXP, subSkillProgress, activeTab,
            meta:{ exportedAt:new Date().toISOString(), version:3 } };
          const blob = new Blob([JSON.stringify(snapshot,null,2)], { type:"application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a"); a.href=url; a.download=`lifexp-backup-${todayISO()}.json`; a.click(); URL.revokeObjectURL(url);
        }
        function importData(file){
          const reader = new FileReader();
          reader.onload = (e)=>{
            try{
              const data = JSON.parse(e.target.result);
              if (!data) return;
              setTasks(data.tasks||[]); setProjects(data.projects||[]); setXp(data.xp||0);
              setSkill(data.skill||{ points:0, upgrades:{} }); setLastLevel(data.lastLevel||0);
              setMilestones(data.milestones||{ claimed:[] }); setLog(data.log||[]);
              setSettings(data.settings||settings); setTheme(data.theme||theme);
              if (data.subjectXP) setSubjectXP(data.subjectXP);
              if (data.subSkillProgress) setSubSkillProgress(data.subSkillProgress);
              if (data.activeTab) setActiveTab(data.activeTab);
              pushAlert("Import successful ✓");
            } catch { alert("Invalid file"); }
          };
          reader.readAsText(file);
        }
        function resetAll(){
          if (!confirm("Reset XP, tasks, projects, skills, milestones, logs? This cannot be undone.")) return;
          setXp(0); setSkill({ points:0, upgrades:{} }); setLastLevel(0); setMilestones({ claimed:[] });
          setTasks(p=> p.map(t=> ({ ...t, streak:0, lastCompleted:null, timesCompletedToday:0 })));
          setProjects(p=> p.map(pr=> ({ ...pr, completedAt:null, steps: pr.steps.map(s=> ({ ...s, done:false, doneAtDate:null })) })));
          setLog([]); setSession(null);
        }

        // ================== UI ==================
        const claimedLevels = milestones.claimed||[];
        const nextMilestone = useMemo(()=> MILESTONES.find(m=> m.level>level), [level]);
        const completedToday = tasks.filter(t=> t.timesCompletedToday>0).length;
        const totalBaseXpToday = tasks.reduce((s,t)=> s + (t.baseXP||0), 0);

        const [showSettings, setShowSettings] = useState(false);

        // ================== NEW: Challenge Functions ==================
        const getCurrentTitles = (level, achievementData) => {
          // Level-based title
          const levelTitle = TITLE_SYSTEM.level
            .filter(t => level >= t.level)
            .sort((a, b) => b.level - a.level)[0] || TITLE_SYSTEM.level[0];

          // Branch titles (would need branch XP tracking)
          const branchTitles = {};

          // Achievement titles
          const achievementTitles = [];
          Object.values(TITLE_SYSTEM.achievement).forEach(category => {
            category.forEach(title => {
              if (title.condition(achievementData)) {
                achievementTitles.push(title);
              }
            });
          });

          // Special titles
          const specialTitles = TITLE_SYSTEM.special.filter(title => 
            title.condition(achievementData)
          );

          return {
            level: levelTitle.title,
            branch: branchTitles,
            achievement: achievementTitles,
            special: specialTitles
          };
        };

        // Update current titles when data changes
        useEffect(() => {
          const newTitles = getCurrentTitles(level, achievementData);
          setCurrentTitles(newTitles);
        }, [level, achievementData]);

        const checkChallengeProgress = (challengeData) => {
          const dailyProgress = CHALLENGES.daily.map(challenge => ({
            ...challenge,
            progress: challenge.check(challengeData),
            completed: challenges.daily.completed.includes(challenge.id)
          }));

          const weeklyProgress = CHALLENGES.weekly.map(challenge => ({
            ...challenge,
            progress: challenge.check(challengeData),
            completed: challenges.weekly.completed.includes(challenge.id)
          }));

          return { daily: dailyProgress, weekly: weeklyProgress };
        };

        const completeChallenge = (challengeId, isWeekly = false) => {
          const challenge = isWeekly 
            ? CHALLENGES.weekly.find(c => c.id === challengeId)
            : CHALLENGES.daily.find(c => c.id === challengeId);
          
          if (!challenge) return;

          // Award rewards
          if (challenge.reward.xp > 0) {
            setXp(x => x + challenge.reward.xp);
          }
          if (challenge.reward.sp > 0) {
            setSkill(s => ({ ...s, points: (s.points || 0) + challenge.reward.sp }));
          }

          // Mark as completed
          if (isWeekly) {
            setChallenges(prev => ({
              ...prev,
              weekly: { ...prev.weekly, completed: [...prev.weekly.completed, challengeId] }
            }));
          } else {
            setChallenges(prev => ({
              ...prev,
              daily: { ...prev.daily, completed: [...prev.daily.completed, challengeId] }
            }));
          }

          pushAlert(`Challenge completed: ${challenge.name} (+${challenge.reward.xp} XP${challenge.reward.sp > 0 ? `, +${challenge.reward.sp} SP` : ''})`);
        };

        const applyTemplate = (templateName) => {
          const template = templates[templateName];
          if (!template) return;

          setForm({
            title: templateName,
            category: template.category,
            taskType: template.taskType,
            difficulty: template.difficulty,
            baseXP: template.baseXP,
            estimateMin: template.estimateMin,
            suggestedXP: template.baseXP,
            showAdvanced: false
          });
        };

        const createCustomTemplate = () => {
          const templateName = prompt("Template name:");
          if (!templateName || !form.title) return;

          const newTemplate = {
            category: form.category,
            taskType: form.taskType,
            difficulty: form.difficulty,
            baseXP: form.baseXP,
            estimateMin: form.estimateMin,
            description: form.title
          };

          setTemplates(prev => ({ ...prev, [templateName]: newTemplate }));
          pushAlert(`Template "${templateName}" created!`);
        };

        // ================== NEW: Smart Scheduling Functions ==================
        const getSmartSuggestion = (category, taskType, difficulty) => {
          const hourlyStats = SMART_SCHEDULING.analyzePatterns(log);
          return SMART_SCHEDULING.suggestOptimalTime(category, taskType, difficulty, hourlyStats);
        };

        // ================== BLENDED PROGRESSION TAB COMPONENT ==================
        
        const BlendedProgressionTab = ({ 
          blendedProgressionEngine, 
          competencySystem, 
          masterySystem, 
          adaptiveSystem, 
          gamificationSystem, 
          researchSystem,
          tasks,
          log,
          settings 
        }) => {
          // Calculate current user profile based on tasks and log
          const userProfile = {
            currentAbility: 0.6, // Default, would be calculated from performance
            performanceHistory: log.slice(-10).map(entry => ({
              score: entry.efficiency || 0.8,
              timestamp: entry.timestamp
            })),
            learningStyle: 'visual', // Would be determined from user preferences
            metacognitiveStrategy: 'planning',
            skillMastery: {}, // Would be calculated from completed tasks
            activeProcessing: true,
            patternRecognition: true,
            metacognitiveReflection: true
          };

          // Sample task for demonstration
          const sampleTask = tasks[0] || {
            id: 'sample',
            title: 'Sample Task',
            subject: 'Math',
            subSkill: 'differential_calculus',
            difficulty: 0.7,
            baseXP: 100
          };

          // Calculate blended progression for sample task
          const progressionData = blendedProgressionEngine.calculateProgression(
            sampleTask, 
            userProfile, 
            userProfile.performanceHistory
          );

          return (
            <div className="space-y-6">
              {/* System Overview */}
              <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-6">
                <div className="flex items-center gap-3 mb-4">
                  <div className="text-3xl">🧠</div>
                  <div>
                    <h1 className="text-2xl font-bold">Blended Progression System</h1>
                    <p className="text-neutral-400">Advanced learning progression combining 5 research-based approaches</p>
                  </div>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-5 gap-4">
                  <div className="p-4 bg-blue-950/30 border border-blue-800 rounded-xl">
                    <div className="text-lg font-semibold text-blue-300 mb-2">1. Competency-Based</div>
                    <div className="text-sm text-neutral-300">Evidence-driven progression with 90%+ mastery thresholds</div>
                  </div>
                  <div className="p-4 bg-purple-950/30 border border-purple-800 rounded-xl">
                    <div className="text-lg font-semibold text-purple-300 mb-2">2. Mastery Learning</div>
                    <div className="text-sm text-neutral-300">Bloom's taxonomy with spaced repetition</div>
                  </div>
                  <div className="p-4 bg-emerald-950/30 border border-emerald-800 rounded-xl">
                    <div className="text-lg font-semibold text-emerald-300 mb-2">3. Adaptive Difficulty</div>
                    <div className="text-sm text-neutral-300">Zone of Proximal Development optimization</div>
                  </div>
                  <div className="p-4 bg-amber-950/30 border border-amber-800 rounded-xl">
                    <div className="text-lg font-semibold text-amber-300 mb-2">4. Gamification</div>
                    <div className="text-sm text-neutral-300">Achievement tiers with meaningful unlocks</div>
                  </div>
                  <div className="p-4 bg-red-950/30 border border-red-800 rounded-xl">
                    <div className="text-lg font-semibold text-red-300 mb-2">5. Research-Based</div>
                    <div className="text-sm text-neutral-300">Cognitive load & learning style optimization</div>
                  </div>
                </div>
              </div>

              {/* Evidence Collection */}
              <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-6">
                <h2 className="text-xl font-semibold mb-4">📋 Evidence Collection System</h2>
                
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
                  {Object.entries(competencySystem.evidenceTypes).map(([type, config]) => (
                    <div key={type} className="p-4 bg-neutral-800 border border-neutral-700 rounded-xl">
                      <div className="flex items-center justify-between mb-2">
                        <div className="font-semibold text-sm">{config.name}</div>
                        <div className="text-xs text-neutral-400">Weight: {config.weight}</div>
                      </div>
                      <div className="text-xs text-neutral-300 mb-2">{config.description}</div>
                      <div className="space-y-1">
                        {config.examples.slice(0, 2).map((example, index) => (
                          <div key={index} className="text-xs text-neutral-400">• {example}</div>
                        ))}
                      </div>
                    </div>
                  ))}
                </div>

                <div className="bg-neutral-800 rounded-xl p-4">
                  <h3 className="font-semibold mb-3">Current Evidence Score</h3>
                  <div className="grid grid-cols-2 md:grid-cols-5 gap-3">
                    {Object.entries(progressionData.evidence).filter(([key]) => key !== 'overallScore' && key !== 'timestamp' && key !== 'taskId').map(([type, score]) => (
                      <div key={type} className="text-center">
                        <div className="text-sm font-semibold">{type.replace('_', ' ')}</div>
                        <div className="text-lg font-bold text-emerald-400">{Math.round(score * 100)}%</div>
                      </div>
                    ))}
                  </div>
                  <div className="mt-3 pt-3 border-t border-neutral-700">
                    <div className="flex justify-between items-center">
                      <span className="font-semibold">Overall Evidence Score</span>
                      <span className="text-xl font-bold text-blue-400">{Math.round(progressionData.evidence.overallScore * 100)}%</span>
                    </div>
                  </div>
                </div>
              </div>

              {/* Mastery Assessment */}
              <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-6">
                <h2 className="text-xl font-semibold mb-4">🎯 Mastery Assessment (Bloom's Taxonomy)</h2>
                
                <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-3 mb-6">
                  {Object.entries(masterySystem.bloomLevels).map(([level, config]) => (
                    <div key={level} className={`p-3 rounded-xl border ${
                      progressionData.masteryLevel.bloomProgress[level]?.mastered 
                        ? 'bg-emerald-950/30 border-emerald-800' 
                        : 'bg-neutral-800 border-neutral-700'
                    }`}>
                      <div className="text-sm font-semibold mb-1">{config.name}</div>
                      <div className="text-xs text-neutral-400 mb-2">{config.description}</div>
                      <div className={`text-lg font-bold ${
                        progressionData.masteryLevel.bloomProgress[level]?.mastered 
                          ? 'text-emerald-400' 
                          : 'text-neutral-400'
                      }`}>
                        {Math.round((progressionData.masteryLevel.bloomProgress[level]?.score || 0) * 100)}%
                      </div>
                      {progressionData.masteryLevel.bloomProgress[level]?.mastered && (
                        <div className="text-xs text-emerald-300 mt-1">✓ Mastered</div>
                      )}
                    </div>
                  ))}
                </div>

                <div className="bg-neutral-800 rounded-xl p-4">
                  <div className="flex items-center justify-between mb-3">
                    <h3 className="font-semibold">Current Mastery Tier</h3>
                    <div className="text-sm text-neutral-400">
                      {Math.round(progressionData.masteryLevel.masteryPercentage * 100)}% Complete
                    </div>
                  </div>
                  <div className="flex items-center gap-4">
                    <div className="text-2xl font-bold text-purple-400 capitalize">
                      {progressionData.masteryLevel.currentTier}
                    </div>
                    {progressionData.masteryLevel.nextTier && (
                      <div className="flex-1">
                        <div className="text-sm text-neutral-400 mb-1">Progress to {progressionData.masteryLevel.nextTier}</div>
                        <div className="w-full bg-neutral-700 rounded-full h-2">
                          <div 
                            className="bg-purple-500 h-2 rounded-full transition-all duration-300"
                            style={{ width: `${Math.round(progressionData.masteryLevel.progressToNext * 100)}%` }}
                          ></div>
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              </div>

              {/* Overall Progression Summary */}
              <div className="bg-gradient-to-r from-purple-900/20 to-blue-900/20 rounded-2xl shadow border border-purple-800/50 p-6">
                <h2 className="text-xl font-semibold mb-4">📈 Overall Progression Summary</h2>
                
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                  <div className="text-center p-4 bg-neutral-800/50 rounded-xl">
                    <div className="text-2xl font-bold text-emerald-400">{Math.round(progressionData.progression.evidenceScore * 100)}%</div>
                    <div className="text-sm text-neutral-400">Evidence Score</div>
                  </div>
                  <div className="text-center p-4 bg-neutral-800/50 rounded-xl">
                    <div className="text-2xl font-bold text-purple-400 capitalize">{progressionData.progression.masteryTier}</div>
                    <div className="text-sm text-neutral-400">Mastery Tier</div>
                  </div>
                  <div className="text-center p-4 bg-neutral-800/50 rounded-xl">
                    <div className="text-2xl font-bold text-amber-400">{progressionData.progression.achievements}</div>
                    <div className="text-sm text-neutral-400">Achievements</div>
                  </div>
                  <div className="text-center p-4 bg-neutral-800/50 rounded-xl">
                    <div className="text-2xl font-bold text-blue-400">{progressionData.progression.experience}</div>
                    <div className="text-sm text-neutral-400">Experience</div>
                  </div>
                </div>
              </div>
            </div>
          );
        };

        return (
          <div className="min-h-screen bg-neutral-950 text-neutral-100 p-6">
            <div className="max-w-6xl mx-auto">
              {/* Alerts */}
              <div className="space-y-2 mb-4">
                {alerts.map(a=>(
                  <div key={a.id} className={`px-3 py-2 rounded-xl shadow-sm text-sm border
                    ${a.kind==="info" ? "bg-emerald-950/50 border-emerald-800 text-emerald-200" : "bg-amber-950/50 border-amber-800 text-amber-200"}`}>
                    {a.message}
                  </div>
                ))}
              </div>

              {/* Tab Navigation */}
              <div className="mb-6">
                <div className="flex space-x-1 bg-neutral-900 p-1 rounded-xl">
                  {[
                    { id: 'dashboard', label: 'Dashboard', icon: '🏠' },
                    { id: 'tasks', label: 'Tasks', icon: '📝' },
                    { id: 'skills', label: 'Skills', icon: '🌳' },
                    { id: 'dual-track', label: 'Dual-Track', icon: '⚡' },
                    { id: 'blended-progression', label: 'Blended Progression', icon: '🧠' },
                    { id: 'projects', label: 'Projects', icon: '🎯' },
                    { id: 'calendar', label: 'Calendar', icon: '📅' },
                    { id: 'analytics', label: 'Analytics', icon: '📊' }
                  ].map(tab => (
                    <button
                      key={tab.id}
                      onClick={() => setActiveTab(tab.id)}
                      className={`flex-1 flex items-center justify-center gap-2 px-4 py-3 rounded-lg font-semibold transition-all ${
                        activeTab === tab.id
                          ? 'bg-blue-600 text-white shadow-lg'
                          : 'text-neutral-400 hover:text-neutral-200 hover:bg-neutral-800'
                      }`}
                    >
                      <span>{tab.icon}</span>
                      <span>{tab.label}</span>
                    </button>
                  ))}
                </div>
              </div>

              <header className="mb-6 flex items-center justify-between">
                <div>
                  <h1 className="text-3xl font-bold">LifeXP</h1>
                  <p className="text-sm text-neutral-400">
                    Level up by completing tasks, projects, and focused sessions.
                    {user && (
                      <span className="ml-2 text-emerald-400">
                        • Synced as {user.email}
                        {isSyncing && " • Syncing..."}
                      </span>
                    )}
                  </p>
                </div>
                <div className="flex items-center gap-2">
                  {user ? (
                    <>
                      <button onClick={syncWithCloud} disabled={isSyncing} 
                        className="px-3 py-2 rounded-2xl bg-blue-600 hover:bg-blue-500 text-white text-sm shadow disabled:opacity-50">
                        {isSyncing ? "Syncing..." : "Sync Now"}
                      </button>
                      <button onClick={handleSignOut} className="px-3 py-2 rounded-2xl bg-neutral-800 hover:bg-neutral-700 text-neutral-100 text-sm shadow">
                        Sign Out
                      </button>
                    </>
                  ) : (
                    <button onClick={()=> setShowAuth(true)} className="px-3 py-2 rounded-2xl bg-emerald-600 hover:bg-emerald-500 text-white text-sm shadow">
                      Sign In / Register
                    </button>
                  )}
                  <button onClick={()=> setShowSettings(s=>!s)} className="px-3 py-2 rounded-2xl bg-neutral-800 hover:bg-neutral-700 text-neutral-100 text-sm shadow">
                    Settings
                  </button>
                  <button onClick={()=> setTheme(t=> t==="dark"?"light":"dark")} className="px-3 py-2 rounded-2xl bg-neutral-800 hover:bg-neutral-700 text-neutral-100 text-sm shadow">
                    {theme==="dark"?"Light":"Dark"}
                  </button>
                  <button onClick={exportData} className="px-3 py-2 rounded-2xl bg-neutral-800 hover:bg-neutral-700 text-neutral-100 text-sm shadow">Export</button>
                  <label className="px-3 py-2 rounded-2xl bg-neutral-800 hover:bg-neutral-700 text-neutral-100 text-sm shadow cursor-pointer">
                    Import
                    <input type="file" accept="application/json" onChange={(e)=> e.target.files?.[0] && importData(e.target.files[0])} className="hidden" />
                  </label>
                  <button onClick={resetAll} className="px-3 py-2 rounded-2xl bg-rose-900/60 hover:bg-rose-800 text-rose-100 text-sm shadow">Reset All</button>
                </div>
              </header>

              {/* Global Progress Overview */}
              <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5 mb-6">
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-xl font-semibold">Global Progress</h2>
                  <div className="text-sm text-neutral-300">
                    Level {level} • {xp} XP
                  </div>
                </div>
                <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                  {Object.entries(SUBJECTS).map(([subjectId, subject]) => {
                    const subjectXPAmount = subjectXP[subjectId] || 0;
                    const subjectLevel = XP_SYSTEM.getSubjectLevel(subjectXPAmount);
                    const progress = (subjectXPAmount % 1000) / 1000 * 100; // Progress within current level
                    
                    return (
                      <div key={subjectId} className="p-4 rounded-xl bg-neutral-800 border border-neutral-700">
                        <div className="flex items-center gap-2 mb-2">
                          <span className="text-lg">{subject.icon}</span>
                          <div className="font-semibold">{subject.name}</div>
                        </div>
                        <div className="text-sm text-neutral-400 mb-1">Level {subjectLevel}</div>
                        <div className="text-xs text-neutral-500 mb-2">{subjectXPAmount} XP</div>
                        <div className="w-full bg-neutral-700 rounded-full h-2">
                          <div 
                            className="bg-blue-500 h-2 rounded-full transition-all duration-300" 
                            style={{ width: `${progress}%` }}
                          />
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>

              {/* Tab Content */}
              {activeTab === 'dashboard' && (
                <div className="space-y-6">
                  {/* Quick Task Creation */}
                  <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5">
                    <h2 className="text-xl font-semibold mb-4">Quick Task Creation</h2>
                    <form onSubmit={addTask} className="grid grid-cols-1 md:grid-cols-6 gap-3">
                      <input
                        className="col-span-2 bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                        placeholder="Task title (e.g., Complete Khan Academy Unit 1)"
                        value={form.title}
                        onChange={(e) => setForm({...form, title: e.target.value})}
                      />
                      <select
                        className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                        value={form.subject}
                        onChange={(e) => {
                          const newSubject = e.target.value;
                          const subjectData = SKILL_TREES[newSubject];
                          const firstMainSkill = Object.keys(subjectData.mainSkills)[0];
                          const firstSubSkill = Object.keys(subjectData.mainSkills[firstMainSkill].subSkills)[0];
                          setForm({
                            ...form,
                            subject: newSubject,
                            mainSkill: firstMainSkill,
                            subSkill: firstSubSkill
                          });
                        }}
                      >
                        {Object.entries(SUBJECTS).map(([id, subject]) => (
                          <option key={id} value={id}>{subject.icon} {subject.name}</option>
                        ))}
                      </select>
                      <select
                        className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                        value={form.subSkill}
                        onChange={(e) => setForm({...form, subSkill: e.target.value})}
                      >
                        {form.subject && Object.entries(SKILL_TREES[form.subject].mainSkills).map(([mainSkillId, mainSkill]) => 
                          Object.entries(mainSkill.subSkills).map(([subSkillId, subSkill]) => (
                            <option key={subSkillId} value={subSkillId}>{subSkill.name}</option>
                          ))
                        )}
                      </select>
                      <select
                        className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                        value={form.difficulty}
                        onChange={(e) => setForm({...form, difficulty: e.target.value})}
                      >
                        <option value="beginner">Beginner</option>
                        <option value="intermediate">Intermediate</option>
                        <option value="advanced">Advanced</option>
                        <option value="expert">Expert</option>
                      </select>
                      <input
                        className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                        type="number"
                        placeholder="Est. min"
                        value={form.estimateMin}
                        onChange={(e) => setForm({...form, estimateMin: Number(e.target.value)})}
                      />
                      <button 
                        type="submit"
                        className="bg-emerald-600 hover:bg-emerald-500 text-white rounded-xl px-4 py-2 font-semibold shadow"
                      >
                        Add Task
                      </button>
                    </form>
                  </div>

                  {/* Mini Tasks List */}
                  <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5 mb-6">
                    <div className="flex items-center justify-between mb-4">
                      <h2 className="text-xl font-semibold">Today's Tasks</h2>
                      <button 
                        onClick={() => setActiveTab('tasks')}
                        className="text-sm text-blue-400 hover:text-blue-300"
                      >
                        Manage All →
                      </button>
                    </div>
                    {tasks.length === 0 ? (
                      <div className="text-center py-8 text-neutral-400">
                        No tasks yet. Add your first task above.
                      </div>
                    ) : (
                      <div className="space-y-3">
                        {tasks.slice(0, 3).map(t => {
                          const completed = (t.timesCompletedToday || 0) > 0;
                          return (
                            <div key={t.id} className="flex items-center gap-3 p-3 rounded-xl bg-neutral-800 border border-neutral-700">
                              <div className="flex-1">
                                <div className="font-semibold text-sm">{t.title}</div>
                                <div className="text-xs text-neutral-400">
                                  {SUBJECTS[t.subject]?.icon} {t.subSkillName} • {t.baseXP} XP
                                </div>
                              </div>
                              <button 
                                onClick={() => completeTask(t.id)} 
                                disabled={completed}
                                className={`px-3 py-1 rounded-lg text-xs font-semibold ${
                                  completed 
                                    ? "bg-neutral-700 text-neutral-500 cursor-not-allowed" 
                                    : "bg-emerald-600 hover:bg-emerald-500 text-white"
                                }`}
                              >
                                {completed ? "Done" : "Complete"}
                              </button>
                            </div>
                          );
                        })}
                        {tasks.length > 3 && (
                          <div className="text-center text-sm text-neutral-400">
                            +{tasks.length - 3} more tasks - <button 
                              onClick={() => setActiveTab('tasks')}
                              className="text-blue-400 hover:text-blue-300"
                            >
                              View All
                            </button>
                          </div>
                        )}
                      </div>
                    )}
                  </div>

                  {/* Mini Projects Overview */}
                  <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5 mb-6">
                    <div className="flex items-center justify-between mb-4">
                      <h2 className="text-xl font-semibold">Active Projects</h2>
                      <button 
                        onClick={() => setActiveTab('projects')}
                        className="text-sm text-blue-400 hover:text-blue-300"
                      >
                        Manage Projects →
                      </button>
                    </div>
                    {projects.length === 0 ? (
                      <div className="text-center py-8 text-neutral-400">
                        No projects yet. Create your first project!
                      </div>
                    ) : (
                      <div className="space-y-3">
                        {projects.filter(p => !p.completedAt).slice(0, 3).map(p => {
                          const total = p.steps.length;
                          const done = p.steps.filter(s => s.done).length;
                          const pct = total === 0 ? 0 : Math.round((done / total) * 100);
                          
                          return (
                            <div key={p.id} className="p-3 rounded-xl bg-neutral-800 border border-neutral-700">
                              <div className="flex items-center justify-between mb-2">
                                <div className="font-semibold text-sm">{p.title}</div>
                                <div className="text-xs text-neutral-400">{done}/{total} steps</div>
                              </div>
                              <div className="w-full bg-neutral-700 rounded-full h-2 mb-2">
                                <div 
                                  className="bg-indigo-500 h-2 rounded-full transition-all duration-300" 
                                  style={{ width: `${pct}%` }}
                                />
                              </div>
                              <div className="text-xs text-neutral-500">
                                {p.dueDate && `Due ${p.dueDate}`} • {p.rewardXP} XP reward
                              </div>
                            </div>
                          );
                        })}
                        {projects.filter(p => !p.completedAt).length > 3 && (
                          <div className="text-center text-sm text-neutral-400">
                            +{projects.filter(p => !p.completedAt).length - 3} more projects
                          </div>
                        )}
                      </div>
                    )}
                  </div>

                  {/* Quick Stats */}
                  <div className="grid grid-cols-1 md:grid-cols-3 gap-3 mb-6">
                    <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-4">
                      <div className="text-sm text-neutral-400">Tasks Completed Today</div>
                      <div className="text-2xl font-bold">{completedToday}</div>
                    </div>
                    <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-4">
                      <div className="text-sm text-neutral-400">Total XP Today</div>
                      <div className="text-2xl font-bold">{sumBy(todayLogs, e=> e.type==="task" || e.type==="project" || e.type==="passive")}</div>
                    </div>
                    <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-4">
                      <div className="text-sm text-neutral-400">Active Projects</div>
                      <div className="text-2xl font-bold">{projects.filter(p => !p.completedAt).length}</div>
                    </div>
                  </div>

                  {/* ML Insights */}
                  <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5 mb-6">
                    <div className="flex items-center justify-between mb-3">
                      <h2 className="text-xl font-semibold">ML Insights & Recommendations</h2>
                      <div className="flex gap-2">
                        <button 
                          onClick={analyzeMLPatterns}
                          className="px-3 py-2 rounded-xl bg-purple-600 hover:bg-purple-500 text-white text-sm shadow"
                        >
                          Analyze Patterns
                        </button>
                        <div className="text-xs text-neutral-400">
                          Confidence: {Math.round((mlData.learning?.confidence || 0.5) * 100)}%
                        </div>
                      </div>
                    </div>
                    
                    {mlData.insights && mlData.insights.length > 0 ? (
                      <div className="space-y-4">
                        {mlData.insights.map((insight, index) => (
                          <div key={index} className={`p-4 rounded-xl border ${
                            insight.type === 'confidence' ? 'bg-purple-950/40 border-purple-800' :
                            insight.type === 'efficiency' ? 'bg-blue-950/40 border-blue-800' :
                            'bg-emerald-950/40 border-emerald-800'
                          }`}>
                            <div className="font-semibold mb-2">{insight.title}</div>
                            <div className="text-sm text-neutral-300 mb-2">{insight.description}</div>
                            <div className="text-xs text-neutral-400 italic">{insight.recommendation}</div>
                          </div>
                        ))}
                      </div>
                    ) : (
                      <div className="text-neutral-400 text-center py-8">
                        Complete more tasks to see ML insights and recommendations
                      </div>
                    )}
                    
                    {Object.keys(xpLearning.userAdjustments).length > 0 && (
                      <div className="mt-4 p-3 bg-neutral-800 rounded-xl">
                        <div className="text-sm font-semibold mb-2">Learning Progress</div>
                        <div className="text-xs text-neutral-400">
                          The system has learned from {Object.keys(xpLearning.userAdjustments).length} of your XP adjustments
                        </div>
                        <div className="mt-2 text-xs text-neutral-500">
                          Last analysis: {mlData.lastAnalysis ? new Date(mlData.lastAnalysis).toLocaleString() : 'Never'}
                        </div>
                      </div>
                    )}
                  </div>

                  {/* Mini Analytics Preview */}
                  <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5 mb-6">
                    <div className="flex items-center justify-between mb-4">
                      <h2 className="text-xl font-semibold">Quick Insights</h2>
                      <button 
                        onClick={() => setActiveTab('analytics')}
                        className="text-sm text-blue-400 hover:text-blue-300"
                      >
                        Full Analytics →
                      </button>
                    </div>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      <div className="p-3 rounded-xl bg-neutral-800 border border-neutral-700">
                        <div className="text-sm font-semibold text-emerald-400 mb-1">Best Work Time</div>
                        <div className="text-xs text-neutral-400">
                          {productivityInsights.bestHours.length > 0 
                            ? `${productivityInsights.bestHours[0].hour}:00 - ${productivityInsights.bestHours[0].hour + 1}:00`
                            : 'Complete more tasks to see patterns'
                          }
                        </div>
                      </div>
                      <div className="p-3 rounded-xl bg-neutral-800 border border-neutral-700">
                        <div className="text-sm font-semibold text-indigo-400 mb-1">Top Category</div>
                        <div className="text-xs text-neutral-400">
                          {productivityInsights.topCategories.length > 0 
                            ? productivityInsights.topCategories[0].category
                            : 'Complete more tasks to see patterns'
                          }
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="mt-8 text-xs text-neutral-500">
                    {user ? (
                      <>Data synced to cloud • Last sync: {cloudBackup.lastSyncTime ? cloudBackup.lastSyncTime.toLocaleString() : 'Never'} • Export/import available</>
                    ) : (
                      <>Data stored locally • Sign in to sync across devices • Export/import available</>
                    )}
                  </div>
                </div>
              )}

              {activeTab === 'skills' && (
                <SkillsTab 
                  activeSubject={activeSubject}
                  setActiveSubject={setActiveSubject}
                  subjectXP={subjectXP}
                  subSkillProgress={subSkillProgress}
                  setForm={setForm}
                  log={log}
                  setActiveTab={setActiveTab}
                />
              )}

              {activeTab === 'dual-track' && (
                <div className="space-y-6">
                  {/* Momentum Track - Level & Banking */}
                  <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5">
                    <div className="flex items-center justify-between mb-4">
                      <h2 className="text-xl font-semibold">⚡ Momentum Track</h2>
                      <div className="text-sm text-neutral-400">
                        Level {dualTrackData.momentum.level || 1} • {dualTrackData.momentum.coins || 0} coins
                      </div>
                    </div>
                    
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                      <div className="p-4 rounded-xl bg-neutral-800 border border-neutral-700">
                        <div className="text-sm text-neutral-400 mb-1">Unbanked XP</div>
                        <div className="text-2xl font-bold text-amber-400">{dualTrackData.momentum.unbankedXP || 0}</div>
                        <div className="text-xs text-neutral-500">At risk after 2 days</div>
                      </div>
                      <div className="p-4 rounded-xl bg-neutral-800 border border-neutral-700">
                        <div className="text-sm text-neutral-400 mb-1">Banking Streak</div>
                        <div className="text-2xl font-bold text-emerald-400">{dualTrackData.momentum.streak || 0}</div>
                        <div className="text-xs text-neutral-500">Daily reviews</div>
                      </div>
                      <div className="p-4 rounded-xl bg-neutral-800 border border-neutral-700">
                        <div className="text-sm text-neutral-400 mb-1">Coins Earned</div>
                        <div className="text-2xl font-bold text-blue-400">{dualTrackData.momentum.coins || 0}</div>
                        <div className="text-xs text-neutral-500">Available to spend</div>
                      </div>
                    </div>

                    {/* Banking Action */}
                    <div className="bg-neutral-800 rounded-xl p-4">
                      <div className="flex items-center justify-between mb-3">
                        <h3 className="font-semibold">Daily Banking</h3>
                        <div className="text-xs text-neutral-400">
                          Last bank: {dualTrackData.momentum.lastBankTime 
                            ? new Date(dualTrackData.momentum.lastBankTime).toLocaleDateString()
                            : 'Never'
                          }
                        </div>
                      </div>
                      
                      {dualTrackData.momentum.unbankedXP > 0 ? (
                        <div className="space-y-3">
                          <div className="text-sm text-neutral-300">
                            You have {dualTrackData.momentum.unbankedXP} XP waiting to be banked. 
                            Take a moment to reflect on your progress today.
                          </div>
                          <button 
                            onClick={() => {
                              const reflection = prompt("Daily reflection (optional): What did you learn today? What will you focus on tomorrow?");
                              if (reflection !== null) {
                                const result = bankingSystem.campAction.processBanking(reflection);
                                pushAlert(`Banked ${result.bankedXP} XP and earned ${result.earnedCoins} coins!`);
                              }
                            }}
                            className="w-full bg-emerald-600 hover:bg-emerald-500 text-white rounded-xl px-4 py-3 font-semibold shadow"
                          >
                            Bank XP & Earn Coins
                          </button>
                        </div>
                      ) : (
                        <div className="text-center text-neutral-400 py-4">
                          No unbanked XP. Complete more tasks to earn momentum XP!
                        </div>
                      )}
                    </div>
                  </div>

                  {/* Mastery Track - Evidence & Unlocks */}
                  <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5">
                    <div className="flex items-center justify-between mb-4">
                      <h2 className="text-xl font-semibold">🎯 Mastery Track</h2>
                      <div className="text-sm text-neutral-400">
                        {dualTrackData.mastery.evidence?.length || 0} evidence pieces
                      </div>
                    </div>

                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                      <div className="p-4 rounded-xl bg-neutral-800 border border-neutral-700">
                        <div className="text-sm text-neutral-400 mb-2">Recent Evidence</div>
                        <div className="space-y-2">
                          {dualTrackData.mastery.evidence?.slice(-3).map((evidence, index) => (
                            <div key={index} className="text-xs p-2 bg-neutral-700 rounded-lg">
                              <div className="font-semibold">{evidence.subskill}</div>
                              <div className="text-neutral-400">+{evidence.xp} XP • {evidence.difficulty}</div>
                            </div>
                          )) || (
                            <div className="text-xs text-neutral-500">No evidence yet</div>
                          )}
                        </div>
                      </div>
                      
                      <div className="p-4 rounded-xl bg-neutral-800 border border-neutral-700">
                        <div className="text-sm text-neutral-400 mb-2">Available Unlocks</div>
                        <div className="space-y-2">
                          {Object.entries(DUAL_TRACK_CONFIG.mastery.unlockRequirements).slice(0, 3).map(([unlockName, unlockData]) => (
                            <div key={unlockName} className="text-xs p-2 bg-neutral-700 rounded-lg">
                              <div className="font-semibold">{unlockName}</div>
                              <div className="text-neutral-400">{unlockData.cost} coins • {unlockData.subject}</div>
                            </div>
                          ))}
                        </div>
                      </div>
                    </div>

                    {/* Unlock Shop */}
                    <div className="bg-neutral-800 rounded-xl p-4">
                      <h3 className="font-semibold mb-3">Unlock Shop</h3>
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                        {Object.entries(DUAL_TRACK_CONFIG.mastery.unlockRequirements).map(([unlockName, unlockData]) => (
                          <div key={unlockName} className="p-3 bg-neutral-700 rounded-lg">
                            <div className="flex items-center justify-between mb-2">
                              <div className="font-semibold text-sm">{unlockName}</div>
                              <div className="text-xs text-blue-400">{unlockData.cost} coins</div>
                            </div>
                            <div className="text-xs text-neutral-400 mb-2">
                              Subject: {unlockData.subject} • Requirements: {JSON.stringify(unlockData.requirements)}
                            </div>
                            <button 
                              onClick={() => {
                                if ((dualTrackData.momentum.coins || 0) >= unlockData.cost) {
                                  setDualTrackData(prev => ({
                                    ...prev,
                                    momentum: {
                                      ...prev.momentum,
                                      coins: prev.momentum.coins - unlockData.cost
                                    },
                                    mastery: {
                                      ...prev.mastery,
                                      unlocks: {
                                        ...prev.mastery.unlocks,
                                        [unlockName]: true
                                      }
                                    }
                                  }));
                                  pushAlert(`Unlocked ${unlockName}!`);
                                } else {
                                  pushAlert("Not enough coins!", "error");
                                }
                              }}
                              disabled={(dualTrackData.momentum.coins || 0) < unlockData.cost || dualTrackData.mastery.unlocks?.[unlockName]}
                              className={`w-full px-3 py-2 rounded-lg text-xs font-semibold ${
                                dualTrackData.mastery.unlocks?.[unlockName] 
                                  ? 'bg-neutral-600 text-neutral-400 cursor-not-allowed'
                                  : (dualTrackData.momentum.coins || 0) >= unlockData.cost
                                    ? 'bg-blue-600 hover:bg-blue-500 text-white'
                                    : 'bg-neutral-600 text-neutral-400 cursor-not-allowed'
                              }`}
                            >
                              {dualTrackData.mastery.unlocks?.[unlockName] ? 'Unlocked' : 'Unlock'}
                            </button>
                          </div>
                        ))}
                      </div>
                    </div>
                  </div>

                  {/* Progression Overview */}
                  <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5">
                    <h2 className="text-xl font-semibold mb-4">📊 Progression Overview</h2>
                    
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      <div className="p-4 rounded-xl bg-neutral-800 border border-neutral-700">
                        <div className="text-sm font-semibold mb-3">Daily Progress</div>
                        <div className="space-y-2 text-sm">
                          <div className="flex justify-between">
                            <span className="text-neutral-400">Tasks Completed:</span>
                            <span>{dualTrackData.progression.dailyTasksCompleted || 0}</span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-neutral-400">Total Tasks:</span>
                            <span>{dualTrackData.progression.totalTasksCompleted || 0}</span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-neutral-400">Last Level Up:</span>
                            <span>{dualTrackData.progression.lastLevelUp 
                              ? new Date(dualTrackData.progression.lastLevelUp).toLocaleDateString()
                              : 'Never'
                            }</span>
                          </div>
                        </div>
                      </div>

                      <div className="p-4 rounded-xl bg-neutral-800 border border-neutral-700">
                        <div className="text-sm font-semibold mb-3">System Status</div>
                        <div className="space-y-2 text-sm">
                          <div className="flex justify-between">
                            <span className="text-neutral-400">ML Confidence:</span>
                            <span>{Math.round((mlData.learning?.confidence || 0.5) * 100)}%</span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-neutral-400">Auto-XP Mode:</span>
                            <span className={settings.autoXPMode ? 'text-emerald-400' : 'text-neutral-400'}>
                              {settings.autoXPMode ? 'Enabled' : 'Disabled'}
                            </span>
                          </div>
                          <div className="flex justify-between">
                            <span className="text-neutral-400">User Level:</span>
                            <span>{settings.userLevel}</span>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {activeTab === 'blended-progression' && (
                <BlendedProgressionTab 
                  blendedProgressionEngine={BLENDED_PROGRESSION_ENGINE}
                  competencySystem={COMPETENCY_SYSTEM}
                  masterySystem={MASTERY_SYSTEM}
                  adaptiveSystem={ADAPTIVE_SYSTEM}
                  gamificationSystem={GAMIFICATION_SYSTEM}
                  researchSystem={RESEARCH_SYSTEM}
                  tasks={tasks}
                  log={log}
                  settings={settings}
                />
              )}

              {activeTab === 'tasks' && (
                <>
                  {/* Existing task content will go here */}
                  <TasksTab form={form} setForm={setForm} addTask={addTask} tasks={tasks} completeTask={completeTask} deleteTask={deleteTask} xpLearning={xpLearning} getMLRecommendation={getMLRecommendation} calculateAutoXP={calculateAutoXP} />
                </>
              )}

              {activeTab === 'projects' && (
                <ProjectsTab 
                  projects={projects}
                  setProjects={setProjects}
                  projForm={projForm}
                  setProjForm={setProjForm}
                  addProject={addProject}
                  deleteProject={deleteProject}
                  addProjectStep={addProjectStep}
                  toggleStep={toggleStep}
                  todayISO={todayISO}
                  uid={uid}
                />
              )}

              {activeTab === 'calendar' && (
                <CalendarTab 
                  tasks={tasks}
                  projects={projects}
                  completeTask={completeTask}
                  deleteTask={deleteTask}
                  todayISO={todayISO}
                  SUBJECTS={SUBJECTS}
                />
              )}

              {activeTab === 'analytics' && (
                <AnalyticsTab 
                  productivityInsights={productivityInsights}
                  weekMetrics={weekMetrics}
                  completedToday={completedToday}
                  totalBaseXpToday={totalBaseXpToday}
                  skillMods={skillMods}
                  currentTitles={currentTitles}
                  challengeData={challengeData}
                  checkChallengeProgress={checkChallengeProgress}
                  challenges={challenges}
                  completeChallenge={completeChallenge}
                  templates={templates}
                  showTemplates={showTemplates}
                  setShowTemplates={setShowTemplates}
                  applyTemplate={applyTemplate}
                  createCustomTemplate={createCustomTemplate}
                  getSmartSuggestion={getSmartSuggestion}
                  form={form}
                  showSmartScheduling={showSmartScheduling}
                  setShowSmartScheduling={setShowSmartScheduling}
                  SMART_SCHEDULING={SMART_SCHEDULING}
                />
              )}

              {/* Authentication Modal */}
              {showAuth && (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
                  <div className="bg-neutral-900 rounded-2xl p-6 w-full max-w-md mx-4 border border-neutral-800">
                    <div className="flex items-center justify-between mb-4">
                      <h2 className="text-xl font-semibold">
                        {authMode === 'login' ? 'Sign In' : 'Create Account'}
                      </h2>
                      <button onClick={() => setShowAuth(false)} className="text-neutral-400 hover:text-neutral-200">
                        ✕
                      </button>
                    </div>
                    
                    <form onSubmit={handleAuth} className="space-y-4">
                      <div>
                        <label className="text-sm text-neutral-400">Email</label>
                        <input
                          type="email"
                          required
                          className="w-full bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2 mt-1"
                          value={authForm.email}
                          onChange={(e) => setAuthForm({...authForm, email: e.target.value})}
                        />
                      </div>
                      
                      <div>
                        <label className="text-sm text-neutral-400">Password</label>
                        <input
                          type="password"
                          required
                          className="w-full bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2 mt-1"
                          value={authForm.password}
                          onChange={(e) => setAuthForm({...authForm, password: e.target.value})}
                        />
                      </div>
                      
                      {authMode === 'register' && (
                        <div>
                          <label className="text-sm text-neutral-400">Confirm Password</label>
                          <input
                            type="password"
                            required
                            className="w-full bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2 mt-1"
                            value={authForm.confirmPassword}
                            onChange={(e) => setAuthForm({...authForm, confirmPassword: e.target.value})}
                          />
                        </div>
                      )}
                      
                      <div className="flex gap-2">
                        <button
                          type="submit"
                          className="flex-1 bg-emerald-600 hover:bg-emerald-500 text-white rounded-xl px-4 py-2 font-semibold"
                        >
                          {authMode === 'login' ? 'Sign In' : 'Create Account'}
                        </button>
                      </div>
                    </form>
                    
                    <div className="mt-4 text-center">
                      <button
                        onClick={() => setAuthMode(authMode === 'login' ? 'register' : 'login')}
                        className="text-sm text-neutral-400 hover:text-neutral-200"
                      >
                        {authMode === 'login' 
                          ? "Don't have an account? Register" 
                          : "Already have an account? Sign In"
                        }
                      </button>
                    </div>
                    
                    <div className="mt-4 text-xs text-neutral-500">
                      Your data will be synced across all devices when signed in.
                    </div>
                  </div>
                </div>
              )}

              {/* Settings panel */}
              {showSettings && (
                <div className="mb-6 p-4 rounded-2xl bg-neutral-900 border border-neutral-800">
                  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3">
                    <div>
                      <div className="text-sm font-semibold">Passive Cap Mode</div>
                      <select value={settings.capMode} onChange={(e)=> setSettings(s=> ({...s, capMode:e.target.value}))}
                        className="mt-1 w-full bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2">
                        <option value="static">Static</option>
                        <option value="dynamic">Dynamic (auto)</option>
                      </select>
                      <div className="mt-2 text-xs text-neutral-400">
                        {settings.capMode==="dynamic"
                          ? <>Auto scales with last-week activity. Today: total <b>{caps.total}</b>, per-category <b>{caps.perCat}</b>.</>
                          : <>Use fields at right. Today: total <b>{caps.total}</b>, per-category <b>{caps.perCat}</b>.</>}
                      </div>
                    </div>
                    <div>
                      <div className="text-sm font-semibold">Static Total Cap (XP/day)</div>
                      <input type="number" value={settings.staticTotal} onChange={(e)=> setSettings(s=> ({...s, staticTotal:Number(e.target.value||0)}))}
                        className="mt-1 w-full bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2" />
                    </div>
                    <div>
                      <div className="text-sm font-semibold">Static Per-Category Cap</div>
                      <input type="number" value={settings.staticPerCat} onChange={(e)=> setSettings(s=> ({...s, staticPerCat:Number(e.target.value||0)}))}
                        className="mt-1 w-full bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2" />
                    </div>
                    <div>
                      <div className="text-sm font-semibold">Auto XP Mode</div>
                      <label className="flex items-center gap-2 mt-1">
                        <input 
                          type="checkbox" 
                          checked={settings.autoXPMode} 
                          onChange={(e)=> setSettings(s=> ({...s, autoXPMode:e.target.checked}))}
                          className="accent-emerald-600"
                        />
                        <span className="text-sm">Enable automatic XP calculation</span>
                      </label>
                      <div className="mt-2 text-xs text-neutral-400">
                        {settings.autoXPMode 
                          ? <>XP calculated automatically using academic knowledge and ML</>
                          : <>Manual XP input required for all tasks</>
                        }
                      </div>
                    </div>
                  </div>
                  {settings.autoXPMode && (
                    <div className="mt-3 p-3 bg-emerald-950/20 border border-emerald-800 rounded-xl">
                      <div className="text-sm font-semibold text-emerald-300 mb-2">User Skill Level</div>
                      <div className="flex items-center gap-2">
                        <input 
                          type="range" 
                          min="1" 
                          max="10" 
                          value={settings.userLevel} 
                          onChange={(e)=> setSettings(s=> ({...s, userLevel:Number(e.target.value)}))}
                          className="flex-1 accent-emerald-600"
                        />
                        <span className="text-sm text-emerald-200 w-8">{settings.userLevel}</span>
                      </div>
                      <div className="text-xs text-neutral-400 mt-1">
                        {settings.userLevel <= 3 ? 'Beginner' : 
                         settings.userLevel <= 6 ? 'Intermediate' : 
                         settings.userLevel <= 8 ? 'Advanced' : 'Expert'} level
                      </div>
                    </div>
                  )}
                  <div className="mt-2 text-xs text-neutral-400">Deadline bonus weekly cap: <b>500 XP</b>. Throughput bonus daily cap: <b>+200 XP</b>.</div>
                </div>
              )}

              {/* Level & Skills */}
              <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5 mb-6">
                <div className="flex items-center gap-4">
                  <div className="text-center">
                    <div className="text-5xl font-extrabold">{level}</div>
                    <div className="text-xs uppercase tracking-wide text-neutral-400">Level</div>
                  </div>
                  <div className="flex-1">
                    <div className="w-full h-3 bg-neutral-800 rounded-full overflow-hidden">
                      <div className="h-full bg-emerald-500" style={{ width: `${Math.round(progress*100)}%` }} />
                    </div>
                    <div className="mt-2 text-xs text-neutral-400">{xp - currentLevelFloor} / {nextLevelFloor - currentLevelFloor} XP to Level {level+1}</div>
                    <div className="mt-1 text-[11px] text-neutral-500">SP/level: 1 + ⌊√L/2⌋ • Milestones 10/25/50/75/100</div>
                    {nextMilestone && (<div className="mt-2 text-xs text-indigo-300">Next milestone: L{nextMilestone.level} (+{nextMilestone.sp} SP • {nextMilestone.badge})</div>)}
                  </div>
                  <div className="text-right">
                    <div className="text-lg font-semibold">{xp} XP</div>
                    <div className="text-xs text-neutral-400">Total</div>
                    <div className="mt-2 text-lg font-semibold">{skill.points ?? 0} SP</div>
                    <div className="text-xs text-neutral-400">Skill Points</div>
                    <button onClick={respecAll} className="mt-2 px-2 py-1 rounded-lg bg-neutral-800 hover:bg-neutral-700 text-neutral-100 text-xs">Respec (refund)</button>
                  </div>
                </div>
                {claimedLevels.length>0 && (
                  <div className="mt-4 flex flex-wrap gap-2">
                    {MILESTONES.filter(m=> claimedLevels.includes(m.level)).map(m=>(
                      <span key={m.level} className="text-[11px] px-2 py-1 rounded-full bg-indigo-900/40 text-indigo-200 border border-indigo-800">{m.badge} • L{m.level}</span>
                    ))}
                  </div>
                )}
              </div>

              {/* Skill Tree */}
              <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5 mb-8">
                <div className="flex items-center justify-between mb-3">
                  <h2 className="text-xl font-semibold">Skill Tree</h2>
                  <div className="text-sm text-neutral-300">Unspent: <span className="font-semibold">{skill.points ?? 0} SP</span></div>
                </div>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                  {Object.values(SKILL_TREE).map(def=>{
                    const lvl = upgLevel(def.key); const atMax = lvl>=def.max; const cost = atMax ? "—" : upgCost(def.key);
                    let effectText = "";
                    if (def.key==="focus") effectText = `Tasks +${Math.min(lvl*2,50)}% • Passive +${Math.min(lvl*1,20)}%`;
                    if (def.key==="scholar") effectText = `Project +${Math.min(lvl*3,60)}%`;
                    if (def.key==="efficiency") effectText = `+${Math.min(lvl,10)} base XP/task`;
                    if (def.key==="momentum") effectText = `Streak cap ${(2 + Math.min(lvl*0.05,0.5)).toFixed(2)}×`;
                    const canBuy = !atMax && (skill.points||0) >= (typeof cost === 'number' ? cost : 9999);
                    return (
                      <div key={def.key} className="p-4 rounded-xl border border-neutral-800 bg-neutral-900">
                        <div className="flex items-start justify-between gap-3">
                          <div>
                            <div className="font-semibold">{def.name}</div>
                            <div className="text-sm text-neutral-300">{def.desc}</div>
                            <div className="mt-1 text-xs text-neutral-400">{effectText}</div>
                          </div>
                          <div className="text-right">
                            <div className="text-sm text-neutral-400">Level</div>
                            <div className="text-xl font-bold">{lvl}/{def.max}</div>
                          </div>
                        </div>
                        <div className="mt-3 flex items-center justify-between">
                          <div className="text-xs text-neutral-400">Next cost: <span className="font-semibold text-neutral-200">{String(cost)}</span> SP</div>
                          <button disabled={!canBuy} onClick={()=>buyUpgrade(def.key)}
                            className={`px-3 py-1.5 rounded-lg text-sm font-semibold shadow
                              ${canBuy ? "bg-violet-600 hover:bg-violet-500 text-white" : "bg-neutral-800 text-neutral-500 cursor-not-allowed"}`}>
                            {atMax? "Maxed":"Upgrade"}
                          </button>
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>

              {/* Mini Focus Session Status */}
              <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5 mb-6">
                <div className="flex items-center justify-between mb-3">
                  <h2 className="text-xl font-semibold">Focus Sessions</h2>
                  <div className="text-sm text-neutral-300">
                    Today: <span className="font-semibold">{todayPassiveTotal}</span> / {caps.total} XP
                  </div>
                </div>
                {session ? (
                  <div className="p-4 rounded-xl bg-neutral-800 border border-neutral-700">
                    <div className="flex items-center justify-between">
                      <div>
                        <div className="text-sm text-neutral-400">Running • {session.category}</div>
                        <Timer startedAt={session.startedAt} targetMinutes={session.targetMinutes} />
                      </div>
                      <div className="flex items-center gap-2">
                        <button onClick={stopSession} className="px-3 py-2 rounded-xl bg-neutral-800 hover:bg-neutral-700 text-neutral-100">Stop</button>
                      </div>
                    </div>
                    <div className="mt-3">
                      <label className="text-xs text-neutral-400">Micro-outcome (required to claim)</label>
                      <input className="w-full bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                        value={focusUI.outcome} onChange={e=> setFocusUI({...focusUI, outcome:e.target.value})}
                        placeholder="What did you accomplish?" />
                      <div className="mt-2 flex gap-2">
                        <button onClick={()=> claimSession(focusUI.outcome)}
                          className="bg-indigo-600 hover:bg-indigo-500 text-white rounded-xl px-4 py-2 font-semibold shadow">Claim XP</button>
                        <button onClick={()=> setSession(null)} className="px-3 py-2 rounded-xl bg-neutral-800 hover:bg-neutral-700 text-neutral-100">Discard</button>
                      </div>
                    </div>
                  </div>
                ) : (
                  <div className="text-center py-4">
                    <div className="text-neutral-400 mb-3">Start a focus session to earn passive XP</div>
                    <button onClick={startSession} className="bg-emerald-600 hover:bg-emerald-500 text-white rounded-xl px-4 py-2 font-semibold shadow">
                      Start Focus Session
                    </button>
                  </div>
                )}
              </div>

              {/* Mini Task Quick Add */}
              <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5 mb-6">
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-xl font-semibold">Quick Add Task</h2>
                  <button 
                    onClick={() => setActiveTab('tasks')}
                    className="text-sm text-blue-400 hover:text-blue-300"
                  >
                    Full Task Manager →
                  </button>
                </div>
                <form onSubmit={addTask} className="grid grid-cols-1 md:grid-cols-3 gap-3">
                  <input 
                    className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                    placeholder="Task title"
                    value={form.title} 
                    onChange={e=> setForm({...form, title:e.target.value})} 
                  />
                  <select 
                    className="bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
                    value={form.subject} 
                    onChange={e=> {
                      const newSubject = e.target.value;
                      const subjectTree = SKILL_TREES[newSubject];
                      const firstMainSkill = Object.keys(subjectTree.mainSkills)[0];
                      const firstSubSkill = Object.keys(subjectTree.mainSkills[firstMainSkill].subSkills)[0];
                      setForm({
                        ...form, 
                        subject: newSubject,
                        mainSkill: firstMainSkill,
                        subSkill: firstSubSkill
                      });
                    }}
                  >
                    {Object.entries(SUBJECTS).map(([id, subject]) => (
                      <option key={id} value={id}>{subject.icon} {subject.name}</option>
                    ))}
                  </select>
                  <button className="bg-emerald-600 hover:bg-emerald-500 text-white rounded-xl px-4 py-2 font-semibold shadow">
                    Add Task
                  </button>
                </form>
              </div>

              {/* Mini Tasks List */}
              <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5 mb-6">
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-xl font-semibold">Today's Tasks</h2>
                  <button 
                    onClick={() => setActiveTab('tasks')}
                    className="text-sm text-blue-400 hover:text-blue-300"
                  >
                    Manage All →
                  </button>
                </div>
                {tasks.length === 0 ? (
                  <div className="text-center py-8 text-neutral-400">
                    No tasks yet. Add your first task above.
                  </div>
                ) : (
                  <div className="space-y-3">
                    {tasks.slice(0, 3).map(t => {
                      const completed = (t.timesCompletedToday || 0) > 0;
                      return (
                        <div key={t.id} className="flex items-center gap-3 p-3 rounded-xl bg-neutral-800 border border-neutral-700">
                          <div className="flex-1">
                            <div className="font-semibold text-sm">{t.title}</div>
                            <div className="text-xs text-neutral-400">
                              {SUBJECTS[t.subject]?.icon} {t.subSkillName} • {t.baseXP} XP
                            </div>
                          </div>
                          <button 
                            onClick={() => completeTask(t.id)} 
                            disabled={completed}
                            className={`px-3 py-1 rounded-lg text-xs font-semibold ${
                              completed 
                                ? "bg-neutral-700 text-neutral-500 cursor-not-allowed" 
                                : "bg-emerald-600 hover:bg-emerald-500 text-white"
                            }`}
                          >
                            {completed ? "Done" : "Complete"}
                          </button>
                        </div>
                      );
                    })}
                    {tasks.length > 3 && (
                      <div className="text-center text-sm text-neutral-400">
                        +{tasks.length - 3} more tasks - <button 
                          onClick={() => setActiveTab('tasks')}
                          className="text-blue-400 hover:text-blue-300"
                        >
                          View All
                        </button>
                      </div>
                    )}
                  </div>
                )}
              </div>

              {/* Mini Projects Overview */}
              <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5 mb-6">
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-xl font-semibold">Active Projects</h2>
                  <button 
                    onClick={() => setActiveTab('projects')}
                    className="text-sm text-blue-400 hover:text-blue-300"
                  >
                    Manage Projects →
                  </button>
                </div>
                {projects.length === 0 ? (
                  <div className="text-center py-8 text-neutral-400">
                    No projects yet. Create your first project!
                  </div>
                ) : (
                  <div className="space-y-3">
                    {projects.filter(p => !p.completedAt).slice(0, 3).map(p => {
                      const total = p.steps.length;
                      const done = p.steps.filter(s => s.done).length;
                      const pct = total === 0 ? 0 : Math.round((done / total) * 100);
                      
                      return (
                        <div key={p.id} className="p-3 rounded-xl bg-neutral-800 border border-neutral-700">
                          <div className="flex items-center justify-between mb-2">
                            <div className="font-semibold text-sm">{p.title}</div>
                            <div className="text-xs text-neutral-400">{done}/{total} steps</div>
                          </div>
                          <div className="w-full bg-neutral-700 rounded-full h-2 mb-2">
                            <div 
                              className="bg-indigo-500 h-2 rounded-full transition-all duration-300" 
                              style={{ width: `${pct}%` }}
                            />
                          </div>
                          <div className="text-xs text-neutral-500">
                            {p.dueDate && `Due ${p.dueDate}`} • {p.rewardXP} XP reward
                          </div>
                        </div>
                      );
                    })}
                    {projects.filter(p => !p.completedAt).length > 3 && (
                      <div className="text-center text-sm text-neutral-400">
                        +{projects.filter(p => !p.completedAt).length - 3} more projects
                      </div>
                    )}
                  </div>
                )}
              </div>

              {/* Quick Stats */}
              <div className="grid grid-cols-1 md:grid-cols-3 gap-3 mb-6">
                <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-4">
                  <div className="text-sm text-neutral-400">Tasks Completed Today</div>
                  <div className="text-2xl font-bold">{completedToday}</div>
                </div>
                <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-4">
                  <div className="text-sm text-neutral-400">Total XP Today</div>
                  <div className="text-2xl font-bold">{sumBy(todayLogs, e=> e.type==="task" || e.type==="project" || e.type==="passive")}</div>
                </div>
                <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-4">
                  <div className="text-sm text-neutral-400">Active Projects</div>
                  <div className="text-2xl font-bold">{projects.filter(p => !p.completedAt).length}</div>
                </div>
              </div>

              {/* ML Insights */}
              <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5 mb-6">
                <div className="flex items-center justify-between mb-3">
                  <h2 className="text-xl font-semibold">ML Insights & Recommendations</h2>
                  <div className="flex gap-2">
                    <button 
                      onClick={analyzeMLPatterns}
                      className="px-3 py-2 rounded-xl bg-purple-600 hover:bg-purple-500 text-white text-sm shadow"
                    >
                      Analyze Patterns
                    </button>
                    <div className="text-xs text-neutral-400">
                      Confidence: {Math.round((mlData.learning?.confidence || 0.5) * 100)}%
                    </div>
                  </div>
                </div>
                
                {mlData.insights && mlData.insights.length > 0 ? (
                  <div className="space-y-4">
                    {mlData.insights.map((insight, index) => (
                      <div key={index} className={`p-4 rounded-xl border ${
                        insight.type === 'confidence' ? 'bg-purple-950/40 border-purple-800' :
                        insight.type === 'efficiency' ? 'bg-blue-950/40 border-blue-800' :
                        'bg-emerald-950/40 border-emerald-800'
                      }`}>
                        <div className="font-semibold mb-2">{insight.title}</div>
                        <div className="text-sm text-neutral-300 mb-2">{insight.description}</div>
                        <div className="text-xs text-neutral-400 italic">{insight.recommendation}</div>
                      </div>
                    ))}
                  </div>
                ) : (
                  <div className="text-neutral-400 text-center py-8">
                    Complete more tasks to see ML insights and recommendations
                  </div>
                )}
                
                {Object.keys(xpLearning.userAdjustments).length > 0 && (
                  <div className="mt-4 p-3 bg-neutral-800 rounded-xl">
                    <div className="text-sm font-semibold mb-2">Learning Progress</div>
                    <div className="text-xs text-neutral-400">
                      The system has learned from {Object.keys(xpLearning.userAdjustments).length} of your XP adjustments
                    </div>
                    <div className="mt-2 text-xs text-neutral-500">
                      Last analysis: {mlData.lastAnalysis ? new Date(mlData.lastAnalysis).toLocaleString() : 'Never'}
                    </div>
                  </div>
                )}
              </div>

              {/* Mini Analytics Preview */}
              <div className="bg-neutral-900 rounded-2xl shadow border border-neutral-800 p-5 mb-6">
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-xl font-semibold">Quick Insights</h2>
                  <button 
                    onClick={() => setActiveTab('analytics')}
                    className="text-sm text-blue-400 hover:text-blue-300"
                  >
                    Full Analytics →
                  </button>
                </div>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div className="p-3 rounded-xl bg-neutral-800 border border-neutral-700">
                    <div className="text-sm font-semibold text-emerald-400 mb-1">Best Work Time</div>
                    <div className="text-xs text-neutral-400">
                      {productivityInsights.bestHours.length > 0 
                        ? `${productivityInsights.bestHours[0].hour}:00 - ${productivityInsights.bestHours[0].hour + 1}:00`
                        : 'Complete more tasks to see patterns'
                      }
                    </div>
                  </div>
                  <div className="p-3 rounded-xl bg-neutral-800 border border-neutral-700">
                    <div className="text-sm font-semibold text-indigo-400 mb-1">Top Category</div>
                    <div className="text-xs text-neutral-400">
                      {productivityInsights.topCategories.length > 0 
                        ? productivityInsights.topCategories[0].category
                        : 'Complete more tasks to see patterns'
                      }
                    </div>
                  </div>
                </div>
              </div>

              <div className="mt-8 text-xs text-neutral-500">
                {user ? (
                  <>Data synced to cloud • Last sync: {cloudBackup.lastSyncTime ? cloudBackup.lastSyncTime.toLocaleString() : 'Never'} • Export/import available</>
                ) : (
                  <>Data stored locally • Sign in to sync across devices • Export/import available</>
                )}
              </div>
            </div>
          </div>
        );
      }

      function AddStepInline({ onAdd }){
        const [title, setTitle] = useState("");
        return (
          <form onSubmit={(e)=>{ e.preventDefault(); onAdd(title); setTitle(""); }} className="mt-3 flex items-center gap-2">
            <input className="flex-1 bg-neutral-800 border border-neutral-700 rounded-xl px-3 py-2"
              placeholder="Add a step (e.g., Finish MIT OCW Calc Lecture 1)"
              value={title} onChange={e=> setTitle(e.target.value)} />
            <button className="bg-indigo-600 hover:bg-indigo-500 text-white rounded-xl px-4 py-2 text-sm font-semibold shadow">Add Step</button>
          </form>
        );
      }

      function Timer({ startedAt, targetMinutes }){
        const [now, setNow] = useState(nowTs());
        useEffect(()=>{ const id=setInterval(()=> setNow(nowTs()), 1000); return ()=> clearInterval(id); }, []);
        const ms = Math.max(0, now - startedAt);
        const s = Math.floor(ms/1000);
        const m = Math.floor(s/60);
        const rem = Math.max(0, targetMinutes - m);
        return (
          <div className="text-lg font-semibold">
            {String(Math.floor(m/60)).padStart(2,'0')}:{String(m%60).padStart(2,'0')}:{String(s%60).padStart(2,'0')}
            <span className="ml-2 text-xs text-neutral-400">({rem} min left target)</span>
          </div>
        );
      }

      function HealthCard({ label, value, hint, ok }){
        return (
          <div className={`p-4 rounded-xl border shadow ${ok? 'bg-emerald-950/40 border-emerald-800' : 'bg-amber-950/40 border-amber-800'}`}>
            <div className="text-sm text-neutral-400">{label}</div>
            <div className="text-2xl font-bold">{value}</div>
            <div className="text-xs text-neutral-400">{hint}</div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById('root')).render(<LifeXPApp />);
    </script>
  </body>
</html>
